# 8장 인덱스

## 8.1 디스크 읽기 방식

- 데이터베이스 성능 튜닝은 디스크 I/O를 줄이는게 관건

### 8.1.1 하드 디스크 드라이브(HDD)와 솔리드 스테이트 드라이브(SSD)

- HDD(DB 서버 병목 초래) 대체를 위한 SSD
- HDD와 같은 인터페이스(SATA, SAS) 지원 &rarr; 내장디스크, DAS, SAN에 사용 가능
  - 참고: https://cheershennah.tistory.com/168
- SSD는 랜덤 I/O 작업이 HDD보다 훨씬 빠르기 때문에 DBMS용 스토리지에 좋음

### 8.1.2 랜덤 I/O와 순차 I/O

- 랜덤 I/O: HDD 플래터를 돌려서 읽어야 할 데이터가 저장된 위치로 디스크 헤더를 이동시킨 다음 데이터를 읽는 것
  - 순차 I/O와 다르게 페이지 당 시스템 콜 요청
    - virtual file system 페이지 vs DB 페이지(mysql-16kb-1page)
       - 다른 거지만 개념적으로 연관성 &uarr;
       - db page fault가 발생하면 (파이로가 이어서 적어주세요)
  - 부하가 큼 &rarr; MySQL 서버에는 그룹커밋, 바이너리 로그 버퍼, InnoDB 로그 버퍼 등 기능 내장
  - 실제는 RAID 컨트롤러 캐시 메모리가 효율적 I/O 처리 도움
    - https://12bme.tistory.com/286
- 쿼리 튜닝으로 랜덤 I/O &rarr; 순차 I/O 하기는 쉽지 않음, 일반적으로 쿼리 튜닝하는 것은 랜덤 I/O 자체를 줄여주는 것이 목적(쿼리를 처리하는 데 꼭 필요한 데이터만 읽도록 쿼리를 개선)
- 랜덤 I/O와 순차 I/O는 결국 데이터를 어떤 단위(크기)로 읽느냐의 차이
  - 페이지 단위로 요청을 주고받으니 랜덤 I/O가 자주 발생
  - SSD가 성능 향상에 유리
  - 인덱스(페이지 내부에서 읽는 건 순차 I/O) -> pk b-tree 다시 읽는 과정 자체가 랜덤 I/O 필요
  - **인덱스도 파일시스템에 저장되어 있음**
    - 인덱스 저장 위치에 대하여
    - 인덱스를 메모리에 저장한다고 가정하면?
    - DB를 실행할 때마다 데이터 레코드 전체를 분석해서 인덱스 구조를 만들어야 함(ㄷㄷㄷ)
    - 삭제, 삽입 (돌려놓고 딴짓, 오래걸림 - DBMS가 처리) - 근데 이걸 메모리가 담당한다면? 애플리케이션과 충돌 lock 등 
    - redo, undo 로그 등등 영속성을 위해 반영하는 것. 메모리상 버퍼에 데이터를 연속적으로 써서 저장해놓고, 나중에 다시 읽어서 DB에 써야지~
    - 데이터베이스 인터널스 왈 "RDBMS는 안전한 데이터베이스를 지향하기 때문에 속도가 저하되더라도 안정성을 확보하는 것이 목표임 trade-off"
- 한 번에 많이 읽는 것 vs 작게 읽는 것 (컴퓨터 시스템 전반과 관련)
  - e.g. cpu->bus / hdd,ssd



## 8.2 인덱스란?

- 찾아보기: 인덱스 / 책 내용: 데이터 파일
- 인덱스를 통해 데이터 파일에 저장된 레코드 주소를 알아낼 수 있음
  - 칼럼 값(key) - 레코드 저장된 주소(value)로 인덱스 만들기
- 책처럼 DBMS의 인덱스도 컬럼 값을 미리 정렬해서 보관
- SortedList: 저장되는 값을 항상 정렬된 상태로 유지하는 자료구조 - 인덱스
  - 데이터가 저장될 때마다 항상 값을 정렬해야 하므로 저장하는 과정이 복잡하고 느리지만, 이미 정렬돼 있어서 아주 빨리 원하는 값을 찾아올 수 있음 &rarr; SELECT는 빠르지만 인덱스가 많은 테이블은 INSERT나 UPDATE 그리고 DELETE 문장의 처리가 느려짐
  - SELECT WHERE 조건절에 사용된다고 다 인덱스 걸면 저장 성능 망함
- ArrayList: 값을 저장되는 순서대로 그대로 유지하는 자료구조 - 데이터 파일
- Primary Key: 레코드를 대표하는 컬럼 값으로 만들어진 인덱스
- Secondary key: primary 제외한 모든 인덱스
- B-Tree 알고리즘: 가장 많이씀, 컬럼의 값을 변형하지 않고, 원래의 값을 이용해 인덱싱하는 알고리즘
- Hash 인덱스 알고리즘: 컬럼의 값으로 해시 값을 계산해서 인덱싱하는 알고리즘, 매우 빠른 검색을 지원, 값을 변형해서 인덱싱하므로, 전방(Prefix) 일치와 같이 값의 일부만 검색하고자 할 때는 해시 인덱스를 사용할 수 없음, 메모리 기반 DB에서 많이 사용
- Unique: 레코드 1건 찾으면 더 안 찾아도 되는 걸 옵티마이저에게 알려줌

## 8.3 B-Tree 인덱스

- 일반적으로 DBMS에서는 주로 B+-Tree 또는 B\*-Tree 사용
  - B(Balanced)
- 컬럼의 원래 값을 변형시키지 않고, 인덱스 구조체 내에서는 항상 정렬된 상태로 유지

### 8.3.1 구조 및 특성

- root node + branch node + leaf node
- leaf node: 실제 데이터 레코드를 찾아가기 위한 주솟값 보유
- 인덱스의 키값은 정렬돼 있지만 데이터 파일의 레코드는 임의의 순서대로 저장
  - 레코드가 중간에 삭제되어 빈 공간이 생기면 다음 INSERT는 빈 공간 활용하기 때문에 데이터 파일의 레코드 != INSERT된 순서임
  - InnoDB 레코드는 클러스터되어 디스크에 저장되기 때문에 PK 순서로 저장됨
    - https://dev.mysql.com/doc/refman/5.7/en/innodb-index-types.html
    - 다른 db는 선택인데 이노 친구는 디폴트로 클러스터링 테이블 생성함
- 인덱스는 테이블의 키 컬럼만 가지고 있으므로 나머지 컬럼을 읽으려면 데이터 파일에서 해당 레코드를 찾아야 함 &rarr; 리프 노드가 데이터 파일에 저장된 레코드의 주소 갖는 이유
- 8.5(MyISAM): PK값과 무관하게 insert 순서대로 레코드가 데이터 파일에 저장 &rarr; ROWID라는 물리적 주솟값 가짐 &rarr; 인덱스가 데이터 파일에 저장된 레코드의 ROWID 값을 포인터로 가짐 (ROWID=secondary index)
- 8.6(InnoDB): PK=ROWID 역할=논리적 주소 &rarr; 인덱스에 저장된 PK(11800)로 프라이머리 키 루트노드 인덱스 키에 맵핑된 자식노드 주소를 타고타고 가 리프 노드에 있는 레코드를 읽는다.
  - secondary index(Aamer)가 PK(11800)를 바라보고 있음
  - PK 저장하고 있는 B-Tree 다시 위에서부터 보면서 11800번 찾음
    - 1번 시나리오
      - 11800어딨을까~
      - 11043? 나 너보다 큰데~ 브랜치 노드로 감
      - 11800? 오~ 찾음~ 레코드로 감
    - 2번 시나리오
      - 10128 어딨을까~
      - 루트노드 봤더니 없네~ 10057 보단 큰데 11043보다는 작네~
      - 또 10057이네~ 내가 이것보단 큰데~ 10418보다는 작네~
      - 오 리프노드 10128 드디어있네~
  - 즉 Inno에서는 PK 검색 아니면 PK B-Tree 인덱스 다시 타줘야 한다.
  - http://www.btechsmartclass.com/data_structures/b-trees.html

- InnoDB의 Secondary index는 pk를 암시적으로 포함하고 있습니다.
  - https://dev.mysql.com/doc/refman/8.0/en/innodb-index-types.html
- 그 pk에 대해서도 정렬이 되어 있는 것 처럼 보입니다. (확인 필요)

```sql
create table test (
    id int primary key auto_increment,
    date datetime not null,
    index idx_date (date)
);

insert into test (date) value ('2022-08-11 14:22:00'); // 4번 반복

update test set date = '2022-09-11 22:22:00' WHERE id = ?; // 임의로 업데이트

SELECT * FROM test ORDER BY date desc;

SELECT * FROM test WHERE id < 3 ORDER BY date desc LIMIT 2;
```

### 8.3.2 B-Tree 인덱스 키 추가 및 삭제

#### 8.3.2.1 인덱스 키 추가

- 바로 저장 &rarr; B-Tree상의 적절한 위치를 검색
- 저장될 위치가 결정되면 레코드의 키값과 대상 레코드의 주소 정보를 B-Tree의 리프 노드에 저장
- 리프노드 꽉차면 분리해야되는데 비용 많이 든다 &rarr; B-Tree 쓰기 작업 비용 많이 드는 이유
  - 비용 계산? 대충 레코드 추가:인덱스에 키 추가=1:1.5
  - 요 작업 MyISAM/MeMory 스토리지 엔진은 INSERT와 동시에 하는데, InnoDB는 똑똑해서 지연시킬 수 있음(PK, UK는 중복체크해야해서 즉시 반영)

#### 8.3.2.2 인덱스 키 삭제

- 키값이 저장된 B-Tree의 리프 노드를 찾아서 삭제 표시
- 요것도 InnoDB는 체인지 버퍼로 지연 처리 가능

#### 8.3.2.3 인덱스 키 변경

- Balanced Tree라 했지? &rarr; 변경하고 싶으면 바꿔치기 안되고 키 값 삭제한 후 새로 추가해야함(키 값으로 리프노드 위치 발란싱하니까)
- 요것도 InnoDB는 체인지 버퍼로 지연 처리 가능

#### 8.3.2.4 인덱스 키 검색

- 인덱스 검색 = 빠른 검색을 위함 = 트리 탐색이라고 함
- SELECT에서만 사용하는 것이 아니라 UPDATE, DELETE 처리하기 위해 레코드를 먼저 검색해야 할 경우에도 사용
- B-Tree 인덱스는 100% 일치 또는 값의 앞부분만 일치하는 경우에만 사용 가능
- 인덱스 키 값 변형된 이후 비교하면 빠른 검색 사용 불가 (B-Tree에 변한건 없으니까 당연)
- InnoDB 테이블에서 지원하는 레코드 잠금 & 넥스트 키 락(갭 락) &rarr; 검색을 수행한 인덱스를 잠근 후 테이블의 레코드를 잠그기 때문에 불필요하게 많은 레코드가 잠길 수 있음

### 8.3.3 B-Tree 인덱스 사용에 영향을 미치는 요소

- 인덱스를 구성하는 칼럼의 크기
- 레코드의 건수
- 유니크한 인덱스 키값의 개수

#### 8.3.3.1 인덱스 키 값의 크기

- 페이지/블록: InnoDB 스토리지 엔진에서 디스크에 데이터를 저장하는 가장 기본 단위
  - 페이지는 InnoDB 스토리지 엔진의 버퍼 풀에서 데이터를 버퍼링하는 기본 단위이기도 함
  - 루트/브랜치/리프 노드 애들도 결국 다 페이지임

- 클러스터: 모여있다. PK로 모아서 저장. 모이는 단위가 저장매체랑 연관(block이랑 1:1 대응하는 것 같음) - 어거스트가 마저 적어주세요
- B-Tree 자식노드 수는 인덱스의 페이지 크기와 키 값의 크기에 따라 결정
  - 페이지 당 저장할 수 있는 인덱스 키 수만큼 레코드 가져올 수 있음
  - 키 값의 크기가 커지면 디스크로부터 여러번 읽어야하고 느려짐

#### 8.3.3.2 B-Tree 깊이

- 인덱스 키 값이 증가 &rarr; 페이지에 당 인덱스 키 수 감소 &rarr; b-tree 깊이 증가 &rarr; 디스크 읽기 횟수 증가

#### 8.3.3.3 선택도(기수성)

- Cardinality = the number of cardinal (basic) members in a set
- Selectivity = Cardinality / Total Number Of Records
- 인덱스의 유니크한 값의 수 &rarr; 인덱스나 쿼리의 성능을 결정(교재 country index 예시 참고)
- Cardinality 는 클수록 좋다! -> Unique!!
- Boolean 컬럼에 인덱스를 거는게 좋은가? Cardinality가 2 &rarr; 1000명 중 2명만 남자, 2명 남자를 검색하기 위해서는 인덱스를 거는게 효율적일 수 있음
- 정렬 혹은 Group by 를 자주할 경우, Cardinality 가 낮아도 인덱스를 걸 가치가 


#### 8.3.3.4 읽어야하는 레코드의 건수

- 손익분기점 잘 판단해야
  - 전체 테이블의 모두 읽어서 필요 없는 50만 건을 버리는 것이 효율적일지, 인덱스를 통해 필요한 50건만 읽어 오는 것이 효율적인지 판단
  - (DBMS 옵티마이저 왈) 인덱스 1건 = 직접 \* 4~5
  - 인덱스 타는 레코드 수가 전체의 20~25% 넘으면 직접 가져와서 필터링하는게 더 효율적

### 8.3.4 B-Tree 인덱스를 통한 데이터 읽기

#### 8.3.4.1 인덱스 레인지 스캔

- 제일 빠름
- 검색해야할 인덱스의 범위가 결정됐을 때 사용하는 방식
- 시작 위치(인덱스 탐색) 찾은 후 리프노드 간 링크를 통해 다음 리프노드를 찾아 스캔(인덱스 스캔)
- 최종 범위(Gad)에 다다르면 멈추고 결과 반환
- 어떤 방식으로 스캔하든 관계 없이, 해당 인덱스를 수정하는 칼럼의 정순 또는 역순으로 정렬된 상태로 레코드를 가져옴
- 인덱스의 리프 노드에서 검색 조건에 맞는 것들을 데이터 파일에서 레코드를 읽어오는 과정이 필요
  - 데이터 레코드 당 랜덤 I/O 한 번씩 발생
  - 커버링 인덱스(쿼리를 충족하는데 필요한 모든 데이터를 갖는 인덱스) 사용 시 디스크 레코드 안 읽어도 된다.
    - https://tecoble.techcourse.co.kr/post/2021-10-12-covering-index/

#### 8.3.4.2 인덱스 풀 스캔

- 인덱스의 처음부터 끝까지 모두 읽는 방식
- 쿼리의 조건절에 사용된 컬럼이 인덱스의 첫 번째 컬럼이 아닌 경우 발생
  - 인덱스는 (A,B,C) 칼럼의 순서대로 만들어져 있지만 쿼리의 조건절에 B 칼럼이나 C 칼럼으로 검색하는 경우
- 과정
  - 인덱스 리프 노드의 처음 또는 끝으로 이동한 후 리프노드를 연결하는 LinkedList 탐색(인덱스 레인지 스캔보단 느리지만 테이블 풀스캔보단 빠름)

#### 8.3.4.3 루스 인덱스 스캔

- 느슨 하게 또는 듬성듬성 하게 인덱스를 읽는 것
- 인덱스 레인지 스캔과 비슷하게 동작하지만, 중간마다 필요치 않은 인덱스 키 값은 스킵
- GROUP BY 또는 집합 함수 가운데 MAX(), MIN() 함수에 대해 최적화에 사용

#### 8.3.4.4 인덱스 스킵 스캔

- MySQL 8.0부터 옵티마이저가 인덱스 두번째 칼럼으로도 인덱스 타게 해줌
- 이게 바로 인덱스 스킵 스캔
- 이전에는 두 번째 칼럼만 where 조건 걸면 인덱스 풀스캔했음(type=index)
- EXPLAIN 찍어보면 지금은 type=range + Extra에 스킵 스캔 나옴
- 제약 사항
  - where 조건절에 안 써준 인덱스 앞에 걸린 컬럼의 유니크한 수가 적어야 함
  - Cardinality 가 작아야 한다.
  - 커버링 인덱스여야함(인덱스 존재하는 컬럼만으로 쿼리 완성)

### 8.3.5 다중 칼럼(Multi-column) 인덱스

- 두 개 이상의 칼럼으로 구성된 인덱스
- 두번째 컬럼은 첫 번째 칼럼에 의존해서 정렬
- 따라서 인덱스 내 컬럼 위치가 중요

### 8.3.6 B-Tree 인덱스의 정렬 및 스캔 방향

- 인덱스를 어느 방향으로 읽을지는 쿼리에 따라서 옵티마이저가 실시간으로 만들어내는 실행 계획에 따라 결정

#### 8.3.6.1 인덱스의 정렬

- MySQL 8.0부터 혼합 정렬 인덱스 사용 가능

##### 8.3.6.1.1 인덱스 스캔 방향

- 옵티마이저가 똑똑해서 인덱스 걸어둔 컬럼에 대해서 정렬하면 가까운 곳에서부터 정순/역순 스캔함

##### 8.3.6.1.2 내림차순 인덱스

- 복합인덱스에서 내림/올림 혼합되면 8.0이 지원하는 내림차순 인덱스만 사용 가능

```sql
CREATE INDEX ix_teamname_userscore ON employees (team_name ASC, User_score DESC);
```

- 만약 한 컬럼을 역순으로 정렬해야하는데 하나는 인덱스 오름차순으로 생성/나머지는 내림차순으로 생성한다면?

```
SELECT * FROM t1 ORDER BY tid ASC LIMIT 12619775, 1;
SELECT * FROM t1 ORDER BY tid DESC LIMIT 12619775, 1;
```

- 12619775번부터 1건 반환해야하는데 역순 정렬 쿼리가 정순 정렬 쿼리보다 28.9% 시간이 더 걸림
- 왜? InnoDB 엔진에서 페이지 잠금이 forward index scan에 더 적합한 구조를 가져서
- 페이지 내부 레코드가 단방향 링크만 가진다. (페이지 간은 doubly인데 안에가 single linked list임)
  - 물리적으로 정렬된게 아니라 페이지 구조가 Heap처럼 연결되어 있는것
- 역순으로 인덱스를 걸지 않으면 어짜피 조회할 때(최신순으로 조회하고 싶음) 역순으로 가져와야해서 비효율 발생, 개인 경험상 역순/정순 차이가 엄청나지 않았음
- 8.0부터는 인덱스 역순/정순 생성할건지까지 저장할 수 있음 - 요거를 탐색할 때 정순이 빠름

### 8.3.7 B-Tree 인덱스의 가용성과 효율성

#### 8.3.7.1 비교 조건의 종류와 효율성

- 다중 컬럼 인덱스에서 각 컬럼의 순서 & 컬럼에 사용된 조건에 따라 인덱스 컬럼 활용 형태가 달라짐

```sql
SELECT * FROM dept_emp WHERE dept_no='d002' AND emp_no >=10144;
```

- INDEX (dept_no, emp_no)
  - dept_no가 d002고 emp_no가 10144 이상인 레코드를 찾은 후 그 d002 끝까지 읽으면 된다.
  - dept_no='d002' AND emp_no >=10144: 작업 범위 결정 조건
- INDEX (emp_no, dept_no)
  - emp_no가 10144인 레코드를 찾은 후 dept_no 적합성을 전부 검증해줘야 한다. (필터링)
  - 다중컬럼인덱스 정렬방식 때문(N번째 키값은 N-1번째 키 값에 의해 다시 정렬됨
  - dept_no='d002': 필터링 조건(체크 조건), emp_no: 작업 범위 결정 조건
  - 작업범위 결정 조건은 많을수록 성능에 유리하지만 체크 조건은 많아도 쿼리 성능을 높이지 못함

#### 8.3.7.2 인덱스의 가용성

- B-Tree 인덱스는 왼쪽값 기준으로 오른쪽값이 정렬됨
- 왼쪽 키 값이 없으면 인덱스 레인지 스캔이 불가

```sql
SELECT * FROM employees WHERE first_name LIKE '%mer';
```

- LIKE 쿼리 왼쪽부분이 고정되지 않았기 때문에 B-tree 인덱스 효과 X

```sql
SELECT * FROM dept_emp WHERE emp_no>=10144;
```

- dept_no 조건이 없기 때문에 다중컬럼 인덱스 제대로 못탄다.
- Left-most 정렬 규칙은 GROUP BY, ORDER BY 절에도 동일하게 적용

#### 8.3.7.3 가용성과 효율성 판단

- 아래 조건들일 경우 인덱스를 작업 범위 결정 조건으로 사용 불가(체크 조건으로만 사용)
  - NOT-EQUAL로 비교
  - LIKE '%??'(뒷부분 일치)
  - 스토어드 함수나 다른 연산자로 인덱스 컬럼이 변형
  - NOT-DETERMINISTIC 속성의 스토어드 함수가 비교조건에 사용
  - 데이터 타입이 서로 다른 비교
  - 문자열 데이터 타입의 콜레이션이 다를 때
- 일반적인 DBMS에서는 Null 값이 인덱스에 저장되지 않지만 MySQL에서는 저장됨
  - 작업 범위 결정 조건으로 인덱스 사용

```sql
.. WHERE column IS NULL ..
```

<br>
<br>
<br>
<br>

## 8.4 R-Tree 인덱스

- Rectangle Tree
- MBR: Minimum Bounding Rectangle
- Spatial Index (공간 인덱스) 라고 부르기도 함
- 반면 B-Tree 는 Scalar Index 임
- RDBMS 에서의 스칼라와 벡터
 - 스칼라 : 값
  - 벡터 : 값 사이의 콜릴레이션(방향?)

### 8.4.1 구조 및 특성
- 모든 도형(삼각형, 사각형, 다각형) 
- R-Tree 인덱스와 B-Tree 인덱스 사이의 차이는 저장하는 데이터의 차이
- 어떤 도형을 감싸는 최소 크기의 사각형으루 변환


### 8.4.2 R-Tree 인덱스의 용도
- 사용예시 : 공간관련, 두 점 사이의 거리가 중요한 경우
  - aribnb 서비스 : 거리
  - 카카오택시
  - 포켓몬고
- 아이작 리포 링크 : https://github.com/janeljs/airbnb/issues/97
- 포인트 : 한점에서 반경 N거리 사이의 뭔가를 찾기 
  - mysql 아니고 다른 DB 쓰는경우도 있음
  - 엘라스틱서치에 편리한거 많음..

## 8.5 전문 검색 인덱스
- 전문검색 : 문서 내용 전체를 인덱스화해서 키워드가 포함된 문서 검색

### 8.5.1 인덱스 알고리즘
- 두가지로 나뉘며 
  - 어근분석
  - n-gram 알고리즘

#### 8.5.1.1 어근분석
- 언어별로 차이가 많다
- MeCab 일본어용 
  - 동양어? 일본어/한글 어근분석보다는 형태소 분석해서 명사/조사 구분 기능이 더 중요
- 사전이 필요하다.. : 학습
- 예시
  - (범주/뛰어가다, 뛰어가서, 뛰다보니..) >> (어근)뛰다 >> 여기에 연결된것들이 검색됨


#### 8.5.1.2 n-gram

- 문장을 이해하는 알고리즘
- 키워드 검색을 위한 인덱싱 
- 예시 (n=2)
    - 뛰어가다 >> 뛰어, 어가, 가다

#### 8.5.1.3 불용어 변경 및 삭제

- 의미없는 불용어 필터링
- 사용자가 직접 등록할수 있다.

### 8.5.2 전문 검색 인덱스의 가용성

- 사용하기 위한 두가지 조건
  - 쿼리 문장이 전문검색위한 문법 사용 
  - 인덱스를 보유해한다
- (추가내용)**MySQL InnoDB full text index 는 inverted index 를 갖는다** @todo질문
    - https://dev.mysql.com/doc/refman/8.0/en/innodb-fulltext-index.html#innodb-fulltext-index-design
- 더 알아보기
  - ES 인버티드 인덱스
  - ELK 기술스텍 
  - 코퍼스(말뭉치)
  - 언어 올림피아드.. 

## 8.6 함수 기반 인덱스
- 함수 기반 인덱스 구현방법
    - 가상 칼럼을 이용한 인덱스
    - 함수를 이용한 인덱스
- B-Tree 와 동일하다 구조 및 유지관리 방법에는


### 8.6.1 가상 칼럼을 이용한 인덱스
- 인덱스는 걸려있는데, 인덱스 걸린값이 컬럼에는 저장되어있지 않음
    - 사용자 입장에서는 안보이고, 내부적으로는 알아서 추가할지도??
- 데이터 정합성을 맞추기 위해서 필요해보임
    - Full-N = first-N + last-N
- 15.8절에서 가상컬럼(파생컬럼) 에서 더욱 자세히 학습예정
    - 스토어드, 버츄얼 : 성능상의 차이를 그떄 공부해보자
@todo질문


### 8.6.2 함수를 이용한 인덱스
- 테이블의 구조를 변경하지 않고 함수를 직접 사용하는 인덱스

## 8.7 멀티 밸류 인덱스
- JSON, 잘 지원한다.

## 8.8 클러스터링 인덱스
- 클러스터링
  - 여러개를 하나로 묶는다!
  - 레코드들이 PK 별로 묶어서 File에 저장되는 형태
  - PK가 비슷한 인근값들을 동시에 조회하는 경우가 확률상 높기 때문
  - 다른 스토리지 엔진(MyISAM 등등..) 에서는 지원되지 않는다
- 면접질문 : InnoDB 랑 다른 스토리지 엔진이랑 차이에 대해 알고 계신가요



### 8.8.1 클러스터링 인덱스
- 클러스터링 인덱스
  - InnoDB 스토리지 엔진에서 사용
  - PK가 비슷한 인근 레코드들끼리 묶여서 같은 File 에 저장되는 방식
  - 뒤집어서 말하면 PK값에 의해서 레코드의 저장 위치가 결정되고, PK가 변경되면 저장되는 File의 위치가 변경된다
  - 인덱싱 알고리즘이 아니라 데이블 레코드의 저장방식 
  - (장점) PK 검색속도가 매우 빠르다, select 성능이 좋다
  - (단점) 저장이나(insert), PK 변경이 상대적으로 느리다(update PK)
- B트리 인덱스 VS 클러스터링 인덱스 차이가 뭔가요
  - B트리 인덱스 : 인덱스가 Key 순서로 정렬되어 저장
  - 클러스터링 인덱스 :  인덱스가 Key 순서로 정렬되어 저장 + PK이어야 함 + 레코드도 PK 순서로 File에 저장되어 있음
  - 한줄요약 : 클러스터링 인덱스 = B트리인덱스 + PK임 + 레코드도 동일한 순서로 저장

> 클러스터링 인덱스 장점
- PK가 저장되는 파일위치가 된다!!
- PK 를 변경하면 일어나는 일
  - 사진으로 대체
- PK 가 없는경우?

  - PK가 없으면 InnoDB는 저장하지 못한다. 그래서 PK를 대체할 컬럼을 선택하고 그 우선순위는
    ```
    1. PK 있으면 PK를 클러스터링 키
    2. NOT NULL + unique 컬럼들 중 첫번째 인덱스 (첫번째로 생성되는 인덱스라는 의미인듯?)
    3. 내부적으로 PK 추가 (NOT NULL + unique + Auto increment 한 컬럼을 알아서 만듬)
    ```

  - 프라이머리 키를 명시적으로 생성하자!  : InnoDB 테이블에서 테이블당 단 하나만 가질수 있는 엄청난 혜택


#### 클러스터링 인덱스 from 데이터베이스 시스템
- ~클러스터링 필드라고 한다~ 
- 클러스터드 인덱스 컬럼 : 레코드가 해당 인덱스 순서로 정렬이 되어서 저장되어 있다!
- MySQL 은 PK 를 기준으로~~

### 8.8.2 세컨더리 인덱스에 미치는 영향

- Quiz) PK랑 NN UNIQUE INDEX 랑은 차이가 뭐가 있나요?
  -	Dong : 어..없지 않을까요...?
  - 정답 : 스토리지엔진별로 차이가 있어요
- MyISAM , MEMORY 엔진 사용 테이블은 아무런 차이가 없다
- InnoDB 엔진 테이블 에서는
  -  NN UNIQUE INDEX 는 인덱스중 하나일뿐이고
  - PK 는 인덱스이면서 동시에 PK 기준으로 정렬되어 파일에 저장되어 있기 때문에 특별
- 274페이지 실습(해봐야함)

### 8.8.3 클러스터링 인덱스의 장점과 단점

| |  특징  | 장점 | 단점 |
| -- | -- | --- | --- |
|1| 테이블의 모든 세컨더리 인덱스가 프라이머리 키를 가지고 있기 때문에 |  인덱스만으로 처리될수 있는 경우가 많음 (커버링인덱스) | 클러스터링 키 값의 크기가 클 경우 모든 인덱스의 크기가 같이 커짐 |
|2| 인덱스를 활용한 검색 | PK 검색시 매우빠름 ,특히 PK기준 범위검색 | 세컨더리 인덱스를 통해 검색해도 결국은 PK로 검색해야하므로 비교적 처리가 느림 |
|3| insert |  | 프라이머리 키에 의해 레코드가 저장되는 파일의 위치가 결정됨 |
|4| update PK |  | PK 업데이트시 : delete >> insert 하기 때문에 처리성능이 느림 |

- 4번 항목(update PK) 의 경우, RDB 에 올라가는 데이터를 delete 날리는 경우는 거의 없고 대부분 log 성으로 쌓는 usecase 가 대부분이 때문에 큰 문제는 아닐꺼같습니다.
- 275p 1/3 지점 : 일반적인 웹서비스와 온라인 트랜잭션 환경에서는 읽기 비율이 80~90% 정도이므로, PK 기준의 읽기속도가 빠른 InnoDB 가 성능이 좋습니다
- 1번 항목이 클러스터링 인덱스를 설명할때 꼭 들어가야하는 내용이라고 생각합니다
- 케이 && 어거스트 생각
  - PK 로만 검색하는것보다는 다른 인덱스 타고 검색하는 경우가 많은데, 이런 상황에서는 성능저하 이슈
  - 인조키 VS 자연키 : mysql 자연키로 검색할때, 앞에 LEFT 가 일치해야 하는 또 제약조건
  - 예시) 자연키로 주민등록번호 가 PK 일때 (880603)
      - 출생년도로 검색 : 인덱스 탐(88XXXX)
      - 출생월로 검색 : 인덱스 X (XX06XX) : 비지니스 로직에 의미가 있음
      - 출생 일로 검색 : 인덱스 X (XXXX03) 
  - 검색에 한해서는 ES 사용하는게 좋을꺼같음 PK 통짜로 검색하는 경우가 적음! 
  - 그럴바에는 안전성있는 인조키 쓰는게 안전쓰..
  - 트랜잭션, 데이터 정합성이 필요 없다면 >> 해시인덱스 더욱 매력적..


### 8.8.4 클러스터링 테이블 사용 시 주의사항
- 클러스터링 엔진을 사용하는 테이블에서 주의사항

#### 8.8.4.1 클러스터링 인덱스 키의 크기
- PK 가 커지면 >> 다른 세컨더리 인덱스 전체도 크기가 커진다
- 왜냐하면 클러스터링 테이블의 경우 모든 세컨더리 인덱스가 PK 값을 가지고 있기 때문
- 인덱스가 커지면 같은 성능을 내기 위해 메모리또한 더 커져야하므로 InnoDB 테이블의 프라이머리 키는 신중하게 선택해야합니다

#### 8.8.4.2 PK를 업무적인 컬럼으로 선택하는 경우(자연키)
- 자연키를 사용할수 있고, 검색에 빈번하게 사용하는 경우 자연키를 PK로 선택하자.
- 설정 그 칼럼의 크기가 크더라도 업무적으로 해당 레코드를 대표할수 있다면! 자연키가 BEST
- 의견)
    - 자연키가 아니더라도 인공적으로 의미를 나타낼수 있다면?
- 상품분류코드의 경우
    - PK = (대분류+중분류+소분류)+유니크
- or 대분류,중분류,소분류 각각을 모두 세컨더리 인덱스로 가져가는 경유
    - trade-off : PK 커지면 >> 모든 인덱스가 같이 증가한다
- PK 자연키가 위험한 이유
    - 카테고리별로 조회하는 경우가 많다.. (PK의 일부가 의미를 갖는 경우)
    - PK의 일부가 상위도메인으로 올라가는 경우
    - 도메인 요구사항이 변경되는 경우
- 레딧 설계 : 스키마 두개로 끝남
- 외래키 거느냐 마느냐 : 외래키 거는 단점
- 설계가 완벽하지 않을수 있다 @@@ 
    - 기술부채 : 미사용 컬럼 삭제

#### 외래키의 위험한
- 두 테이블간의 강력한 (데이터)의존성
- 두 객체 사이의 커플링, 결합도
- 최근 트렌드는 MSA 라서 의존성 낮추는게 좋음
- RDBMS 에 모든 데이터를 집중하기엔 스케일업이 어려움 : 샤딩
- 유지보수가 진짜 어렵다
    - 코드랑 설계랑 따로논다 >> 문서가 없을수도
    - 코드랑 문서랑 따로논다 

#### 8.8.4.3 PK는 꼭 명시하자
- 어차피 사용자가 명시적으로 생성하지 않아도 InnoDB 는 내부적으로 PK컬럼을 만들어낸다
- ROW 기반 복제 ??
- 정상적인 복제를 위해서는 PK가 필요하다??


#### 8.8.4.4 PK에 인공키 (AUTO-INCREMENT)
- 로그테이블로 INSERT 위주의 테이블들은 AUTO-INCREMENT 이용하면 도움이 된다
- 여러개의 컬럼이 복합으로 프라이머리 키가 만들어지는 경우 프라이머리 키가 길어질 떄가 가끔 있다 >> 이런경우 인공키를 써라


## 8.9 유니크 인덱스
- INDEX 없이 유니크 제약을 설정하는건 불가능하다(insert 성능이 최소 O-n)

### 8.9.1 유니크 인덱스와 일반 세컨더리 인덱스의 비교
#### 8.9.1.1 유니크 인덱스 읽기
- 유니크 인덱스와 유니크하지 않은 인덱스 사이에 성능차이는 크지 않다
  - 왜냐하면 해당작업은 CPU 작업이니까! DB 성능은 DISK IO 줄이기 싸움


#### 8.9.1.2 유니크 인덱스 쓰기
- 인덱스 쓰기에서는 유니크 제한이 쓰기성능이 더 느리게 동작(유니크 인덱스는 쓰기성능이 나쁘다)
- 쓰기동작에서 중복인지 아닌지를 체크하기 위해 락이 걸린다
- 버퍼링도 할수 없다.

### 8.9.2 유니크 인덱스 사용 시 주의사항
- 도메인관점에서 비지니스 로직에 꼭 필요한 경우에만 유니크 제약을 추가하자

## 8.10 외래키
- 외래키 제약이 설정되면 연관테이블에 컬럼에는 인덱스가 자동으로 생긴다

### 8.10.1 자식 테이블의 변경이 대기하는 경우
- 자식 테이블의 외래키 컬럼의 변경은 부모테이블의 확인이 필요하고
  - 이 상태에서 부모 테이블의 해당 레코드가 쓰기 잠금이 걸려있으면 해제시까지 대기한다
- 자식테이블의 외래키아닌 컬럼은 그런거 없다 잠금도 대기도 없다


### 8.10.2 부모 테이블의 변경 작업이 대기하는 경우
- 체크를 위해 연관 테이블 읽기 잠금이 걸린다
- 트랜잭션이 다른 테이블로 확장(전파된다) >> 트랜잭션 범위가 너무 커지는 문제 발생


> 끝!
