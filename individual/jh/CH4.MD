## 4장 : 요약 (첫 읽기)

- MySQL 의 전체구조
    - MySQL 서버
        - 두뇌 : MySQL 엔진
            - 커넥션 핸들러
            - SQL 인터페이스SQL 파서, SQL 옵티마이저,
            - 메모리 캐시&버퍼
        - 손,발 : 스토리지 엔진 (InnoDB, MyISAM 등…)
    - 운영체제 하드웨어 (디스크의 데이터파일과 로그파일)
- 스토리지 엔진은 핸들러 API 만 만족하면 InnoDB, MyISAM 외에도 추가가능, 즉 플러거블하다. 심지어 테이블 단위로도 스토리지 엔진 선택 가능함
- 핸들러
    - 핸들러 요청 : 데이터를 쓰거나 읽기 위해 MySQL이 각 스토리지 엔진에 쓰기, 또는 읽기를 요청하는 것을
    - 핸들러 API : 핸들러 요청을 처리
- MySQL 의 스레드 모델 (스레드 기반)
    - 포그라운드(==사용자 스레드)와 백그라운드가 있다.
    - 메모리의 캐시&버퍼는 >> 디스크의 데이터파일로 저장되고
    - 메모리의 로그 버퍼는 >> 디스크의 로그 파일로 저장된다
- 포그라운드 스레드
    - 클라이언트 쿼리 문장 (요청)을 처리, 하고 쓰레드 캐시로 이동하거나 너무 많으면 종료됨
    - 직접 데이터 버퍼나 케시로부터 데이터를 가지고오고 없으면…
        - (innoDB는) 백그라운드 스레드가 데이터나 인덱스 파일로부터 데이터를 읽어온다.
        - (MyISAM은)  포그라운드 스레드가 데이터나 인덱스 파일로부터 데이터를 읽어온다.
- 백그라운드 스레드
    - Insert Buffer를 병합하는 스레드 (로그
    - 로그를 디스크로 기록하는 스레드
    - InnoDB의 버퍼풀의 데이터를 디스크에 기록하는 스레드
    - 데이터를 버퍼로 읽오는 스레드
    - 잠금이나 데드락을 모니터링하는 스레드
- MySQL 메모리 구조 (글로벌 메모리 영역 + 세션/커넥션 메모리 영역)
- 세션/커넥션 메모리 영역
    - 스레드 메모리랑 동일함, MySQL 도 결국 네트워크를 타고 요청을 받는 하나의 서버이기때문
    - 커넥션과 결과 버퍼는 계속 할당되어지고 정렬과 조인 버퍼는 쿼리 실행시에만 할당된다.
- 플러그인 아키텍처는 8.0 부터 컴포넌트 아키텍처로 대체… 단점은?
    - 플러그인은 MySQL이랑만 통신하고 플러그인끼리 통신이안됨
    - MySQL 서버 변수를 직접 호출해서 캡슐화가 안됨
    - 상호 의존 관계를 설정할 수 없어서 초기화가 어려움

## 4장 : 핵심
