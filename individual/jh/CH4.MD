## 4장 : 요약 (첫 읽기)

- 아키텍처
	- MySQL 의 전체구조는 `MySQL 서버`와 `운영체제 하드웨어`로 나뉜다.
	- MySQL 서버는 다시 `MySQL 엔진`과 `스토리지 엔진으`로 나뉜다.
	- MySQL 엔진은 두뇌의 역할을 담당하고 구성은 `커넥션 핸들러, 인터페이스, SQL 파서, SQL 옵티마이저, 메모리 캐시 & 버퍼`가 있다.
	- 스토리지 엔진은 손, 발의 역할을 담당하고 대표적으로는 `InnoDB, MyISAM` 이 있다.
	- 운영체제 하드웨어는 `디스크의 데이터파일과 로그파일` 등이 있다.
- 스토리지 엔진
	- 스토리지 엔진은 pluggable 한데, `핸들러 API`만 만족하면 InnoDB, MyISAM 외에 다른 스토리지 엔진도 설정할 수 있으며 직접 구현도 가능하다.
	- 심지어 테이블 단위로도 스토리지 엔진 선택 가능하다.
- 핸들러?
	- **핸들러 요청**은 데이터를 쓰거나 읽기 위해 MySQL이 각 스토리지 엔진에 쓰기, 또는 읽기를 요청하는 것을
	- 핸들러 API : 핸들러 요청 처리 방법을 명세하는 API
- MySQL의 스레드
	- `포그라운드(==사용자 스레드)`와 `백그라운드`가 있다.
- 메모리 to 디스크 연관관계
	- 메모리의 `캐시와 버퍼`는 >> 디스크의 `데이터 파일`로 저장되고
	- 메모리의 `로그 버퍼`는 >> 디스크의 `로그 파일`로 저장된다
- 포그라운드 스레드
	- 요청받은 클라이언트 쿼리 문장을 처리하고 쓰레드 캐시로 이동하거나 너무 많으면 종료됨
	- 직접 데이터 버퍼나 케시로부터 데이터를 가지고오고 없으면…
		- `innoDB`는 **백그라운드 스레드**가 데이터나 인덱스 파일로부터 데이터를 읽어온다.
		- `MyISAM`은 **포그라운드 스레드**가 데이터나 인덱스 파일로부터 데이터를 읽어온다.
- 백그라운드 스레드의 종류
	- Insert Buffer를 병합하는 스레드 \(로깅)
	- 로그를 디스크로 기록하는 스레드
	- InnoDB의 버퍼풀의 데이터를 디스크에 기록하는 스레드
	- 데이터를 버퍼로 읽오는 스레드
	- 잠금이나 데드락을 모니터링하는 스레드
- MySQL 메모리 구조 \(글로벌 메모리 영역 + 세션/커넥션 메모리 영역)
- 글로벌 메모리 영역은 `InnoDB 버퍼풀, MyISAM 키캐시, 빈 로그 버퍼, 리두 로그 버퍼, 테이블 캐시` 등으로 구성되어 있다.
- 세션/커넥션 메모리 영역은 `조인,정렬, 네트워크, 리드 버퍼` 등으로 구성되어 있다.
	- 스레드 메모리랑 원리적으로 유사하게 요청에 대한 데이터만 스레드 로컬
	- MySQL 도 결국 네트워크를 타고 요청을 받는 하나의 서버이기 때문
	- `커넥션과 결과 버퍼는 계속 할당`되어지고 `정렬과 조인 버퍼는 쿼리 실행시에만 할당`된다.
- 플러그인 아키텍처는 아래 단점들이 있어서 8.0 버전부터 컴포넌트 아키텍처로 대체되었다.
	- 플러그인끼리 통신이 어렵다.
	- MySQL 서버 변수를 직접 호출해서 캡슐화가 안된다.
	- 상호 의존 관계를 설정할 수 없어서 초기화가 어려움
- `쿼리 실행 구조`와 각 부분들의 역할
	- 쿼리파서 == 문법 검사
	- 전처리기 == 구조적 문제 확인
	- 옵티마이저 == `두뇌`, 여러 실행 플랜들 중 최적의 실행방법을 선정
	- 실행엔진 == 옵티마이저가 세운 실행계획을 핸들러에게 전달
	- 핸들러 == 스토리지 엔진이다. InnoDB 테이블을 조작 할 경우 핸들러가 InnoDB 스토리지 엔진, MyISAM…
- `쿼리 캐시`는 쿼리 결과를 캐싱해서 사용하는데 캐시 Invalidation 이 많이 발생하면서 데이터 정합성이 떨어져서 버그가 너무 많이 발생해 MySQL 8.0부터 삭제
- `스키마 변경 작업도 트랜잭션 기반`의 **InnoDB 스토리지 엔진**에 저장되기 때문에 스키마 변경중 비정상 종료에도 완전 실패나 성공으로 정리된다.
- InnoDB 스토리지 엔진 아키텍처
	- MySQL 에서 사용가능한 엔진 중 거의 유일하게 레코드 기반 잠금이 가능해서 동시성이 뛰어나다.
	- 프라이머리 키에 의한 클러스터링
- **MVCC*****
	- `레코드 레벨의 트랜잭션`을 지원하는 DBMS가 제공하는 기능
	- `잠금을 사용하지 않는 일관된 읽기`를 제공하는데 하나의 레코드에 대해 여러 개의 버전이 동시에 관리
	- InnoDB 에서는 `언두 로그`를 통해 구현
	- 쓰기 작업이 영속되기 전까지 기존 데이터는 메모리의 언두 영역에 보관
	- **트랜잭션 레벨**에 따라서 다른 트랜잭션이 조회하는 데이터를 `버퍼풀\(Read-uncommitted)`에서 조회하거나 그 이상의 `언두 로그\(Read-uncommited or higher)`에서
	  가져온다.
- 잠금없는 일관된 읽기 : 트랜잭션 레벨 `Serializable` 을 제외한 격리 수준에서는 잠금을 기다리지않고 읽기작업을 수행
- InnoDB는 `데드락 감지 스레드`를 가지고있어서 주기적으로 교착상태에 빠진 스레드들을 종료시킨다.
	- 롤백의 비용이 낮은 쪽을 종료 시킨다 == 언두로그에 롤백해야 하는 데이터가 적은 쪽을 종료
	- 데드락 감지 스레드 사용은 옵션으로 **ON/OFF 가능** 하고 off시에도 **lock timeout 설정** 가능
	- ??? 잠금 대기 목록에 저장된 테이블을 다시 새로 잠그고 데드락을 찾기 때문에 양이 많아지면 많은 CPU 소모가능
- InnoDB의 버퍼풀 [InnoDB 버퍼풀 자료구조](https://dev.mysql.com/doc/refman/8.0/en/innodb-buffer-pool.html)
	- 디스크의 데이터와 인덱스 정보를 메모리에 캐시해 두는 공간
	- 버퍼풀의 크기를 줄이는건 늘리는 것보다 서비스 성능에 영향도가 크기때문에 주의
	- 버퍼풀은 기본 128MB 청크단위로 관리한다. 버퍼풀 관리하는 잠금\(세마포어) 도 경합이 분산됨
	- 버퍼풀의 구조
		- 페이지 크기에 맞게 일정 크기의 조각으로 쪼개서 관리
		- 구성은...
			- LRU와 MRU결합된 형태의 리스트
			- 플러쉬리스트 : 디스크로 동기화되지 않은 리스트
			- 프리리스트 : 사용되지 않은 페이지들의 리스트
		- LRU,MRU는 페이지 단위의 양방향 linkedin list 형태로 조회하는 데이터를 찾아서 리스트에 추가하는데....
			- 버퍼풀에 이미 있으면 head 방향으로 이동
			- 디스크에서 불러오는 데이터는 리스트으 5/8 지점에 삽입해준다.
		- 버퍼풀의 플러시
			- 플러시 리스트의 플러시 : 클리너 스레드라는 더티 페이지를 디스크로 동기화하는 스레드가 있다.
			- 더티페이지의 비율이 있다.
- InnoDB의 리두로그
	- 리두 로그 공간의 낭비를 막기위해 데이터 페이지의 변경된 내용만 기록한다.
	- `partial-page` 또는 `torn-page` 더티페이지를 디스크 파일로 플러시 할때 일부분만 기록되는 문제가 발생하면 그 페이지의 내용은 복구할 수 없을 수도 있다.
	- 위와 같은 문제를 방지하고자 double-write 기법을 이용한다.\(아래참고)
	- 주기적으로 체크포인트 이벤트를 발생 \(리두로그파일 크기의 제한도 있음) 디스크에 플러시 해주는 것
- Double Write 버퍼 \(on/off옵션, 데이터 일관성이 중요할 때 사용)
	- INNODB 엔진에서 더티페이지를 디스크 파일로 플러시 할 때 일부만 기록되는 문제가 발생하면 복구가 어려움
	- 그래서 버퍼풀은 더티 페이지들을 `한번에 묶어서 한번의 디스크쓰기`로 `시스템 테이블스페이스의 DOUBLE-WRITE 버퍼`에 기록한다.
	- 그리고 InnoDB 스토리지 엔진은 각 더티 페이지를 랜덤으로 쓰기를 실행한다.
	- double write 버퍼는 쓰기 디스크에 영속하는데 실패 할때만 필요
	- 데이터 무결성이 중요한 서비스에 많이 활용된다.
- 언두 로그
	- 트랜잭션과 격리수준을 보장하기 위해 DML로 인해 데이터가 변경되기 전에 별도로 백업하는 데이터
	- 트랜잭션 : dml 이전의 데이터를 미리 언두로그에 복사해두고 롤백시에 다시 데이터를 이동 복구시킨다.
	- 격리 수준 : 수준에 따라 언두로그의 데이터 또는 커밋되지 않은 데이터\(READ-UNCOMMITED)를 리턴
	- mysql5.6 이전 버전에서는 언두 로그를 모두 시스템 테이블 스페이스에 저장했지만 시스템 테이블스페이스는 서버 초기화시에 고정되기때문에 이후 8.0버전 부터는 별도의 로그 파일에 기록되도록 개선되었다.
- 체인지 버퍼
	- INSERT나 UPDATE 시 인덱스를 업데이트하는 작업에서 랜덤 DISK READ 가 발생하는데 이를 방지하기 위해 변경대상 인덱스 페이지가 버퍼 풀에 있으면 바로 수정하지만 그렇지 않을 경우에 임시로
	  버퍼링해두는곳
	- 반드시 중복여부가 체크되어야하는 **유니크 인덱스는 체인지 버퍼를 사용할 수 없다.**
	- 체인지 버퍼에 저장된 인덱스 레코드 조각은 이후 백그라운드 스레드인 **머지 스레드**에 의해 병합된다.
	- MySQL 5.6 이전에는 insert 문에만 적용이 가능했지만, 이후에는 DML 모두가 버퍼 대상이고 변수로 insert/delete/update 중 설정 가능
- 리두 로그는 FAILURE 을 대비해서 항상 활성화되어있지만 대량 데이터 적재 같은 필요에 따라 on/off를 할 수도 있다.
- 어댑티브 해시 인덱스
	- 사용자가 자주 요청하는 데이터에 대해 자동으로 생성되는 `key-value` 자료구조
	- 구성
		- key : B-Tree 인덱스의 고유번호 + 실제 키 값 조합으로 생성
		- value : 데이터 페이지 주소 \(버퍼 풀에 로딩된 메모리 주소)
	- 어댑티브 해시 인덱스는 스토리지 엔진 당 하나가 존재한다.
	- 자주 읽히는 데이터 페이지의 키 값을 이용해 해시 인덱스를 만들고 저장된 데이터 페이지에 즉시 접근
	- 캐시라고 보면됨
	- 장점
		- 쿼리성능이 증가한다. 리프 노드 찾는 시간이 단축되면 cpu가 상대적으로 적은 일을 하기 때문에
	- 단점
		- 추가적인 관리비용, 메모리에서 사용하기 때문에 세마포어, 경합도 고려해야한다. \(다행히 파티셔닝은 가능)
		- 메모리 차지
		- 많이 사용하지 않으면 오히려 짐이 된다.
- 거의 모든 엔진이 InnoDB으로 대체되는 중이다.
- MyISAM 의 메모리 키캐시
	- innodb의 버퍼풀이라고 보면됨
	- 하지만 키캐시는 **인덱스 대상으로만 동작**하고 대부분 디스크 쓰기 작업에 대해서만 운영체제가 부분적인 버퍼링 진행
	- 인덱스는 빠르게 검색할 수 있지만 테이블의 데이터에 대해서는 디스크 I/O 를 해결해 줄 만한 어떠한 캐시나 버퍼링 기능도 가지고 있지 않다
	- 디스크의 읽기, 쓰기 작업은 운영체제가 담당하게 되는데 InnoDB 만큼 전문적이지가 않다
	- 고려해야할 부분은 운영체제의 캐시는 남는 메모리를 활용하기 때문에 다른 서비스나 MySQL서버의 다른 부분들이 메모리를 가득채우지 않게 키캐시를 최대 물리메모리의 40%로 설정하고 나머지는 운영체제가 자체
	  캐시 공간을 마련할 수 있도록 양보해야한다.
- 데이터 파일과 프라이머리 키 구조
    - InnoDB는 pk값으로 클러스터링 되어 저장된다.
    - MyISAM 테이블의 레코드는 프라이머리 키 값과 무관하게 INSERT 되는 순서대로 데이터 파일에 저장된다.
    - MyISAM 의 레코드들은 모두 ROWID 라는 물리적인 주솟값을 가지고 인덱스들 모두 저장된 레코드의 rowid 값을 포인터로 가진다.
- 슬로우쿼리
    - 슬로우 쿼리 로그를 보면 MySQL 은 잠금은 MyISAM 이나 MEMORY의 경우 스토리지레벨의 잠금을 가지고 있지않지만 InnoDB의 경우 MySQL엔진레벨과 스토리지 엔진 레벨 두 개의 잠금을 가지고 있다.

## 4장 : 핵심

- MySQL 서비스와 스토리지 엔진
