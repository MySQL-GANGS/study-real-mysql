## 4장 : 요약 (첫 읽기)

- 아키텍처
    - MySQL 의 전체구조는 `MySQL 서버`와 `운영체제 하드웨어`로 나뉜다.
    - MySQL 서버는 다시 `MySQL 엔진`과 `스토리지 엔진으`로 나뉜다.
    - MySQL 엔진은 두뇌의 역할을 담당하고 구성은 `커넥션 핸들러, 인터페이스, SQL 파서, SQL 옵티마이저, 메모리 캐시 & 버퍼`가 있다.
    - 스토리지 엔진은 손, 발의 역할을 담당하고 대표적으로는 `InnoDB, MyISAM` 이 있다.
    - 운영체제 하드웨어는 `디스크의 데이터파일과 로그파일` 등이 있다.
- 스토리지 엔진
    - 스토리지 엔진은 pluggable 한데, `핸들러 API`만 만족하면 InnoDB, MyISAM 외에 다른 스토리지 엔진도 설정할 수 있으며 직접 구현도 가능하다.
    - 심지어 테이블 단위로도 스토리지 엔진 선택 가능하다.
- 핸들러?
    - **핸들러 요청**은 데이터를 쓰거나 읽기 위해 MySQL이 각 스토리지 엔진에 쓰기, 또는 읽기를 요청하는 것을
    - 핸들러 API : 핸들러 요청 처리 방법을 명세하는 API
- MySQL의 스레드
    - `포그라운드(==사용자 스레드)`와 `백그라운드`가 있다.
- 메모리 to 디스크 연관관계
    - 메모리의 `캐시와 버퍼`는 >> 디스크의 `데이터 파일`로 저장되고
    - 메모리의 `로그 버퍼`는 >> 디스크의 `로그 파일`로 저장된다
- 포그라운드 스레드
    - 요청받은 클라이언트 쿼리 문장을 처리하고 쓰레드 캐시로 이동하거나 너무 많으면 종료됨
    - 직접 데이터 버퍼나 케시로부터 데이터를 가지고오고 없으면…
        - `innoDB`는 **백그라운드 스레드**가 데이터나 인덱스 파일로부터 데이터를 읽어온다.
        - `MyISAM`은 **포그라운드 스레드**가 데이터나 인덱스 파일로부터 데이터를 읽어온다.
- 백그라운드 스레드의 종류
    - Insert Buffer를 병합하는 스레드 \(로깅)
    - 로그를 디스크로 기록하는 스레드
    - InnoDB의 버퍼풀의 데이터를 디스크에 기록하는 스레드
    - 데이터를 버퍼로 읽오는 스레드
    - 잠금이나 데드락을 모니터링하는 스레드
- MySQL 메모리 구조 \(글로벌 메모리 영역 + 세션/커넥션 메모리 영역)
- 글로벌 메모리 영역은 `InnoDB 버퍼풀, MyISAM 키캐시, 빈 로그 버퍼, 리두 로그 버퍼, 테이블 캐시` 등으로 구성되어 있다.
- 세션/커넥션 메모리 영역은 `조인,정렬, 네트워크, 리드 버퍼` 등으로 구성되어 있다.
    - 스레드 메모리랑 원리적으로 유사하게 요청에 대한 데이터만 스레드 로컬
    - MySQL 도 결국 네트워크를 타고 요청을 받는 하나의 서버이기 때문
    - `커넥션과 결과 버퍼는 계속 할당`되어지고 `정렬과 조인 버퍼는 쿼리 실행시에만 할당`된다.
- 플러그인 아키텍처는 아래 단점들이 있어서 8.0 버전부터 컴포넌트 아키텍처로 대체되었다.
    - 플러그인끼리 통신이 어렵다.
    - MySQL 서버 변수를 직접 호출해서 캡슐화가 안된다.
    - 상호 의존 관계를 설정할 수 없어서 초기화가 어려움
- `쿼리 실행 구조`와 각 부분들의 역할
    - 쿼리파서 == 문법 검사
    - 전처리기 == 구조적 문제 확인
    - 옵티마이저 == `두뇌`, 여러 실행 플랜들 중 최적의 실행방법을 선정
    - 실행엔진 == 옵티마이저가 세운 실행계획을 핸들러에게 전달
    - 핸들러 == 스토리지 엔진이다. InnoDB 테이블을 조작 할 경우 핸들러가 InnoDB 스토리지 엔진, MyISAM…
- `쿼리 캐시`는 쿼리 결과를 캐싱해서 사용하는데 캐시 Invalidation 이 많이 발생하면서 데이터 정합성이 떨어져서 버그가 너무 많이 발생해 MySQL 8.0부터 삭제
- 스`키마 변경 작업도 트랜잭션 기반`의 **InnoDB 스토리지 엔진**에 저장되기 때문에 스키마 변경중 비정상 종료에도 완전 실패나 성공으로 정리된다.
- InnoDB 스토리지 엔진 아키텍처
    - MySQL 에서 사용가능한 엔진 중 거의 유일하게 레코드 기반 잠금이 가능해서 동시성이 뛰어나다.
    - 프라이머리 키에 의한 클러스터링
- **MVCC*****
    - `레코드 레벨의 트랜잭션`을 지원하는 DBMS가 제공하는 기능
    - `잠금을 사용하지 않는 일관된 읽기`를 제공하는데 하나의 레코드에 대해 여러 개의 버전이 동시에 관리
    - InnoDB 에서는 `언두 로그`를 통해 구현
    - 쓰기 작업이 영속되기 전까지 기존 데이터는 메모리의 언두 영역에 보관
    - **트랜잭션 레벨**에 따라서 다른 트랜잭션이 조회하는 데이터를 `버퍼풀\(Read-uncommitted)`에서 조회하거나 그 이상의 `언두 로그\(Read-uncommited or higher)`에서
      가져온다.
- 잠금없는 일관된 읽기 : 트랜잭션 레벨 `Serializable` 을 제외한 격리 수준에서는 잠금을 기다리지않고 읽기작업을 수행
--------------------- cleaned up to here 
- InnoDB는 데드락 감지 스레드를 가지고있어서 주기적으로 교착상태에 빠진 스레드들을 종료시킨다.
    - 롤백의 비용이 덜한쪽 \(언두로그에 데이터가 덜 들어있는 쪽을 롤백)
    - 데드락 감지 스레드 사용은 옵션으로 ON/OFF 가능 하고 off시에도 lock timeout 설정가능
    - 잠금 대기 목록에 저장된 테이블을 다시 새로 잠그고 데드락을 찾기때문에 양이 많아지면 많은 CPU 소모가능
- InnoDB의 버퍼풆
    - 디스크의 데이터 파일이나 인덱스 정보를 메모리에 캐시해 두는 공간
    - 쓰기 지연도 하는 버퍼 역할도 함
    - 버퍼풀의 크기를 줄이는건 영향도가 크기때문에 주의
    - 버퍼풀은 기본 128MB 청크단위로 관리한다. 버퍼풀 관리하는 잠금\(세마포어) 도 경합이 분산됨
- 버퍼풀의 구조
    - 페이지 크기 조각으로 쪼개서 관리
    - 구성은...
        - LRU와 MRU결합된 형태의 리스트
        - 플러쉬리스트 : 디스크로 동기화되지 않은 리스트
        - 프리리스트 : 사용되지 않은 페이지들의 리스트
    - LRU,MRU는 페이지 단위의 양방향 linkedin list 형태로 조회하는 데이터를 찾아서 리스트에 추가하는데....
        - 버퍼풀에 이미 있으면 head 방향으로 이동
        - 디스크에서 불러오는 데이터는 리스트으 5/8 지점에 삽입해준다.
- 버퍼풀의 리두로그
    - 버퍼풀은 클린페이지와 함께 INSERT/DELETE/UPDATE 등의 변경이 적용된 더티페이지도 가지고 있음
    - 주기적으로 체크포인트 이벤트를 발생 \(리두로그파일 크기의 제한도 있음) 디스크에 플러시 해주는 것
- 버퍼풀의 플러시
    - 플러시 리스트의 플러시 : 클리너 스레드라는 더티 페이지를 디스크로 동기화하는 스레드가 있다.
    - 더티페이지의 비율이 있다.
- Double Write 버퍼 \(on/off옵션, 데이터 일관성이 중요할 때 사용)
    - INNODB 엔진에서 더티페이지를 디스크 파일로 플러시 할 때 일부만 기록되는 문제가 발생하면 복구가 어려움
    - 그래서 버퍼풀은 더티 페이지들을 한번에 묶어서 한번의 디스크쓰기로 시스템 테이블스페이스의 DOUBLE-WRITE 버퍼에 기록한다.
    - 그리고 InnoDB 스토리지 엔진은 각 더티 페이지를 랜덤으로 쓰기를 실행한다.
    - double write 버퍼는 쓰기 디스크에 영속하는데 실패할때만 필요...
- 언두 로그
    - 트랜잭션과 격리수준을 \(mvcc)보장하기 위해 DML로 변경되기 전의 데이터를 별도로 백업하는 곳
    - 트랜잭션 : 롤백 시에 사용
    - 격리 수준 : 수준에 따라 언두로그, 또는 커밋되지 않은 데이터를 리턴
    - mysql5.6 이전 버전에서는 언두 로그를 모두 시스템 테이블 스페이스에 저장했지만 시스템 테이블스페이스는 서버 초기화시에 고정되기때문에 이후 8.0버전 부터는 별도의 로그 파일에 기록되도록 개선되었다.
- 체인지 버퍼
    - INSERT나 UPDATE 시에 인덱스를 업데이트 하는 작업도 필요한데 랜덤한 DISK READ 가 발생한다.
    - 이를 방지하기 위해 변경대상 인덱스 페이지가 버퍼 풀에 있으면 바로 수정하지만 그렇지
      않을경우에 임시로 버퍼링해두는곳
    - 반드시 중복여부가 체크되어야하는 ****유니크 인덱스는 체인지 버퍼를 사용할 수없다.
    - 체인지 버퍼에 저장된 인덱스 레코드 조각은 이후 백그라운드 스레드인 **머지 스레드**에 의해 병합된다.
    - 5.6 이전에는 insert만, 이후에는 DML 모두가 버퍼 대상이고 변수로 insert/delete/update 중 명시 \(설정) 가능
- 리두로그는 FAILURE을 대비해서 항상 활성화되어있지만 필요에따라\(대량적재) on/off를 할 수도 있다.
- 어댑티브 해시 인덱스
    - 사용자가 자주 요청하는 데이터에 대해 자동 생성하는 자료구조
    - 구성
        - key : B-Tree 인덱스 고유번호 + 실제 키 값 조합으로 생성
        - value : 데이터 페이지 주소 \(버퍼 풀에 로딩된 메모리 주소)
    - 어댑티브 해시 인댁스는 하나만생성되서 스토리지 엔진 당 하나
    - B-Tree 인덱스 조회 속도의 빠름 여부는 매우 상대적이기 때문에!
    - 자주 읽히는 데이터 페이지의 키 값을 이용해 해시 인덱스를 만들고 저장된 데이터 페이지에 즉시 접근
    - 캐시라고 보면됨
    - 장점
        - 쿼리성능 증가 == \(리프 노드 찾는 시간 단축 + cpu 적은일)
    - 단점
        - 추가적인 관리비용, 메모리에서 사용하기 때문에 세마포어, 경합도 고려해야한다. \(다행히 파티셔닝은 가능)
        - 데이터 일관성 맞춰야함
        - 메모리 차지
        - 많이 사용하지않으면 짐
    - 내 생각에는 가급적 비활성화하고 관리 비용을 낮추는게 맞는것으로 보임
- 거의 모든 엔진이 InnoDB으로 대체되는 중
- MyISAM 의 메모리키캐시== innodb의 버퍼풀이라고 보면됨
    - 하지만 키캐시는 인덱스 대상으로만 동작하고 대부분 디스크 쓰기 작업에 대해서만 부분적인 버퍼링 진행
    - 인덱스는 빠르게 검색할 수 있지만 테이블의 데이터에 대해서는 디스크 I/O 를 해결해 줄 만한 어떠한 캐시나 버퍼링 기능도 가지고 있지 않다.
    - 디스크의 읽기, 쓰기 작업은 운영체제가 담당하게 되는데 InnoDB 만큼 전문적이지가 않다.
    - MySQL운영체제의 캐시는 남는 메모리를 활용하기때문에 다른 서비스나 MySQL서버의 다른 부분들이 메모리를 가득채우지않게 키캐시를 최대 물리메모리의 40% 로 설정하고 나머지는 운영체제가 자체
      캐시 공간을 마련할 수 있도록 양보해야한다.
- 데이터 파일과 프라이머리 키 구조
    - InnoDB는 pk값으로 클러스터링 되어 저장되는 반면 MyISAM 테이블의 레코드는 프라이머리 키 값과 무관하게 insert 되는 순서대로 데이터 파일에 저장된다.
    - myisam 의 레코드들은 모두 ROWID 라는 물리적인 주솟값을 가지고 인덱스들 모두 저장된 레코드의 rowid 값을 포인터로 가진다.
- 슬로우쿼리
    - MySQL 은 잠금은 MyISAM 이나 MEMORY의 경우 스토리지레벨의 잠금을 가지고 있지않지만 InnoDB의 경우 MySQL엔진레벨과 스토리지 엔진 레벨 두 개의 잠금을 가지고 있다.

## 4장 : 핵심
