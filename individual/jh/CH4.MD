## 4장 : 요약 (첫 읽기)

- MySQL 의 전체구조
    - MySQL 서버
        - 두뇌 : MySQL 엔진
            - 커넥션 핸들러
            - SQL 인터페이스SQL 파서, SQL 옵티마이저,
            - 메모리 캐시&버퍼
        - 손,발 : 스토리지 엔진 (InnoDB, MyISAM 등…)
    - 운영체제 하드웨어 (디스크의 데이터파일과 로그파일)
- 스토리지 엔진은 핸들러 API 만 만족하면 InnoDB, MyISAM 외에도 추가가능, 즉 플러거블하다. 심지어 테이블 단위로도 스토리지 엔진 선택 가능함
- 핸들러
    - 핸들러 요청 : 데이터를 쓰거나 읽기 위해 MySQL이 각 스토리지 엔진에 쓰기, 또는 읽기를 요청하는 것을
    - 핸들러 API : 핸들러 요청을 처리
- MySQL 의 스레드 모델 (스레드 기반)
    - 포그라운드(==사용자 스레드)와 백그라운드가 있다.
    - 메모리의 캐시&버퍼는 >> 디스크의 데이터파일로 저장되고
    - 메모리의 로그 버퍼는 >> 디스크의 로그 파일로 저장된다
- 포그라운드 스레드
    - 클라이언트 쿼리 문장 (요청)을 처리, 하고 쓰레드 캐시로 이동하거나 너무 많으면 종료됨
    - 직접 데이터 버퍼나 케시로부터 데이터를 가지고오고 없으면…
        - (innoDB는) 백그라운드 스레드가 데이터나 인덱스 파일로부터 데이터를 읽어온다.
        - (MyISAM은)  포그라운드 스레드가 데이터나 인덱스 파일로부터 데이터를 읽어온다.
- 백그라운드 스레드
    - Insert Buffer를 병합하는 스레드 (로그
    - 로그를 디스크로 기록하는 스레드
    - InnoDB의 버퍼풀의 데이터를 디스크에 기록하는 스레드
    - 데이터를 버퍼로 읽오는 스레드
    - 잠금이나 데드락을 모니터링하는 스레드
- MySQL 메모리 구조 (글로벌 메모리 영역 + 세션/커넥션 메모리 영역)
- 세션/커넥션 메모리 영역
    - 스레드 메모리랑 동일함, MySQL 도 결국 네트워크를 타고 요청을 받는 하나의 서버이기때문
    - 커넥션과 결과 버퍼는 계속 할당되어지고 정렬과 조인 버퍼는 쿼리 실행시에만 할당된다.
- 플러그인 아키텍처는 8.0 부터 컴포넌트 아키텍처로 대체… 단점은?
    - 플러그인은 MySQL이랑만 통신하고 플러그인끼리 통신이안됨
    - MySQL 서버 변수를 직접 호출해서 캡슐화가 안됨
    - 상호 의존 관계를 설정할 수 없어서 초기화가 어려움
- 쿼리 실행 구조
    - 쿼리파서 (문법오류)
    - 전처리기 (구조적 문제 확인)
    - 옵티마이저 (두뇌, 최적의 실행방법)
    - 실행엔진 (옵티마이저가 세운 실행계획을 핸들러에게 전달)
    - 핸들러 (==스토리지 엔진), InnoDB 테이블을 조작할경우 핸들러가 InnoDB 스토리지 엔진, MyISAM…
- 쿼리 캐시 : 커리 결과를 캐싱하는데 버그도 많고 Invalidation 이 너무 많아 버그의 원인이 되기도함. MySQL 8.0부터 삭제
- 스레드풀 : MySQL 커뮤니티 에디션에는 없다고함
- 스키마 변경 작업도 트랜잭션 기반의 InnoDB 스토리지 엔진에 저장되기 때문에 스키마 변경중 비정상 종료에도 완전 실패나 성공으로 정리된다.
- InnoDB 스토리지 엔진 아키텍처
    - MySQL 에서 사용가능한 엔진 중 거의 유일하게 레코드 기반 잠금이 가능해서 동시성이 뛰어나다.
    - 프라이머리 키에 의한 클러스터링
- **MVCC*****
    - 레코드 레벨의 트랜잭션을 지원하는 DBMS가 제공하는 기능
    - 잠금을 사용하지 않는 일관된 읽기를 제공하는데 하나의 레코드에 대해 여러 개의 버전이 동시에 관리
    - MVCC를 InnoDB는 언두 로그를 통해 구현
    - 쓰기 작업이 영속되기 전까지 기존 데이터는 메모리의 언두 영역에 보관되고 **트랜잭션 레벨**에 따라서 ReadUncommitted \(버퍼풀)이나 그 이상의 격리수준 \(언두 로그)에서 가져온다.
- 잠금없는 일관된 읽기
    - SERIALIZABLE을 제외한 격리 수준에서는 잠금을 기다리지않고 읽기작업을 수행
- InnoDB는 데드락 감지 스레드를 가지고있어서 주기적으로 교착상태에 빠진 스레드들을 종료시킨다.
    - 롤백의 비용이 덜한쪽 \(언두로그에 데이터가 덜 들어있는 쪽을 롤백)
    - 데드락 감지 스레드 사용은 옵션으로 ON/OFF 가능 하고 off시에도 lock timeout 설정가능
    - 잠금 대기 목록에 저장된 테이블을 다시 새로 잠그고 데드락을 찾기때문에 양이 많아지면 많은 CPU 소모가능
- InnoDB의 버퍼풆
    - 디스크의 데이터 파일이나 인덱스 정보를 메모리에 캐시해 두는 공간
    - 쓰기 지연도 하는 버퍼 역할도 함
    - 버퍼풀의 크기를 줄이는건 영향도가 크기때문에 주의
    - 버퍼풀은 기본 128MB 청크단위로 관리한다. 버퍼풀 관리하는 잠금\(세마포어) 도 경합이 분산됨
- 버퍼풀의 구조
  - 페이지 크기 조각으로 쪼개서 관리
  - LRU와 MRU, 그리고 FREE가 결합된 형태
  - 

## 4장 : 핵심
