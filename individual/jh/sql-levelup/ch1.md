스터디 : SQL 레벨업

1장

* 1장은 아키텍처를 주로 다룬다.
* SQL 레벨업은 옵티마이저가 제공하는 쿼리 최적화에; 중점을 둔다.
* 트랜잭션, 락 매니저 등의 동시성 관련 내용 대신 하나의 쿼리를 최적화된 방법으로 실행하는데에 둔다.
* 쿼리 평가엔진은 실행 계획을 만들어낸다.
* 버퍼 매니저
* 디스크 용량 매니저
* 트랜잭션, 락매니저
* (주혁) 하드디스크 / 메모리 구분이 사라질 수도 있지 않을까?
* 데이터 캐시와 로그 버퍼는 각각 read 를 위한 I/O 비용과 write을 위한 I/O 비용을 최적화가 목적
* 로그버퍼는 디스크에 쓰기를 (버퍼) 지연하면서 I/O 최적화 목적인데 데이터 정합성이 중요한 케이스에서는 write 발생시 로그버퍼를 동기화 할 수 있을 것이라고 생각이된다. 이럴때를 위해 CQRS 가 있는 것일 수도…. Read 목적의 DB와 Write 목적의 DB를 별도로 두면서 말이다.
* DB의 기본 설정 값들을 보면 갱신보다는 “검색”이 “주” 인 서비스들이다. MySQL의 데이터 캐시 기본 크기와 로그버퍼 기본 크기만 비교해봐도 알 수 있음.
* 워킹메모리
	* 데이터 캐시, 로그 버퍼 외의 제3의 메모리 영역
	* InnoDB에서는 sort_buffer_size 로 크기 조절 가능한 메모리 영역.
	* Group-by 테이블, 정렬, 윈도우 함수, 서브 쿼리, 해시 조인 등에 사용된다.
	* 워킹 메모리 크기가 한계를 넘으면 메모리 스왑이 발생, 즉 디스크까지 저장 영역이 확장된다.
	* 그래서….! 조인 쿼리의 결합 키도 중요하고 드라이빙 vs 드리븐 테이블 중요
* 실행계획은 fully-managed 지만 내부 동작 원리를 알아야한다.
	* 옵티마이저가 항상 최적의 실행계획을 만들어내는 것은 아니다.
	* 옵티마이저가 실행계획을 만들어내기 위해 참고하는 통계 정보가 얼마나 정확한지에 따라 성능이 갈리기 때문에.

1장 요약

* DB 는 기본적으로 검색이 “주”를 이루는 것을 가정한다.
	* 단편적인 예로 데이터베이스에서 기본 설정을 보면 ( 메모리의 버퍼풀 크기 > 로그버퍼 크기 )
* working memory 란? (MySQL에서 sort_buffer_size 라 불리움)
	* SELECT 의 sort, hash, group-by 부분에 사용된다.
	* 부족하면 임시테이블까지(disk) 확장이 되서 슬로우 쿼리 발생시키는데 멀티 스레드 환경에서는 기습적으로 발생하기 때문에 가급적 피해야한다
* 실행계획
	* 데이터에 접근하는 방법으로 검색의 성능을 결정한다.
	* 쿼리가 너무 복잡하면 옵티마이저도 최적의 실행계획을 못찾을 가능성이 있다.
* 카탈로그 매니저 (통계정보 관리자)
	* ANALYZE 테이블….단위로 가능하다.
	* 레코드 수, 필드 수, 필드 값 크기, 카디널리티, 히스토그램, Null 비중, 인덱스 정보 등을 관리한다.
	* 통계정보를 동기, 비동기적으로  추적한다.
	* 갱신작업에 어느 빈도로 반영이 되야하는가
	* 통계정보는 테이블, 인덱스에 관한 정보
	* 샘플 데이터 데이터 페이지 20개 >>> 설정 가능, 커질수록 더 디테일 통계정보 >>> 업데이트 하는데 성능 부하
	* 통계정보가 더 최신일수록, 더 많은 를 참고할 수록 옵티마이저가 최적의 쿼리를 찾을 확률은 높지만 이 또한 성능적 트레이드 오프가 있다.
* DBMS 관점에서 보는 메모리와 디스크 (메모리 vs 디스크)
	* 영속여부 / 메모리의 휘발성 디스크는 영속적
	* 속도 / 메모리가 훨 빠름. 디스크 I/O 작업은 항상느리다
		* I/O 작업 최적화
	* 기억비용 / 메모리 확장이 비용이 상대적으로 많이든다. 디스크는 저렴하다.
* Buffer, Cache 등은 디스크 접근을 최소화 하기 위해 만들어둠 ***I/O 작업 최적화
* 대부분의 RDBMS 는 메모리 위에 2개의 버퍼가 있음
	* 데이터 캐시 : 예시로 InnoDB의 버퍼풀 이라고 한다.
	* 로그 버퍼 : 성능을 위해 디스크에 데이터 변경사항을 반영하는 작업 (I/O)의 버퍼
		* 일정량까지 변경사항을 버퍼해두고 한번에 COMMIT을 해서 >> I/O 최적화 >> 성능
		* 데이터 변경 작업의 동기, 비동기 여부와 그에 따른 정합성 등의 트레이드 오프를 고려해야한다
* 쿼리 평가 엔진 실행 절차
	* Parser (문법체크) > 카탈로그 매니저의 (통계 정보 활용) > 옵티마이저 (많은 플랜생성) > 옵티마이저 (비용평가) > 플랜 평가 > 접근 메소드 (DBMS_
* 인덱스 스캔
	* B-+ Tree
	* B-Tree 구조의 인덱스를 타고 들어가 검색하는 시간이 있어서 손익분기점은 존재한다.
	* B+Tree 는 리프노드만 데이터를 가지게된다.
	* 리프노드, 데이터가 많아질 수록 금세 상대적으로 효율적으로 변한다.
	* 중간 노드에도 데이터를 조회하면
	* ???? 탐색 알고리즘 + 데이터 조회
* 조인
	* Nested Loop : (경우에 따라 working 메모리 사용해서 ) for loop 사용
		* 2중포문, 결합키의 인덱스여부에따라 임시테이블 사용이 달라지는 경우가 있다.
	* Sort Merge : (거의 default로 working 메모리 사용해서) 결합 키 기준 정렬
	* Hash : (거의 default로 working 메모리 사용해서) 해시테이블을 만들어야해서 메모리 영역 사용

1장 목표 포인트

* 일반적인 DBMS의 아키텍처를 설명 할 수 있다.
* 디스크와 메모리의 트레이드 오프를 설명 할 수 있다.
* 메모리의 특성인 휘발성에 따른 트레이드오프를 데이터베이스의 구조의 일부인 로그버퍼와 연관지어 설명 할 수 있다.
* DBMS 특성 (검색이 주)과 연관지어서 데이터캐시 vs 로그버퍼의 연관성을 설명할 수 있다.
* 워킹 메모리에 대해서 설명할 수 있다.
	* 워킹 메모리 == 필요하긴한데, BAD IDEA, 튀면 디스크
	* 조인, 윈도우 함수
* 쿼리 평가 엔진의 실행 절차에 대해 설명할 수 있다. ***
* 통계 정보의 중요성과 포함되어있는 내용들을 알고 있다.
	* 통계 정보 : 비동기 Analyze
	* 대규모 변경 발생을 고려한다.
* 각 조인 알고리즘을 설명할 수 있다.

1장 스터디 후기

- 책 내용 요약은 혼자서도 잘할 수 잇는데
- 스터디를 통해 견해를 넓혀가는, 각자의 생각을 공유해서 좋다
- 스터디 많이 하는 다혜님

——————————————————————————————————————————————————————

뒷풀이 토크

- [x] 코트린 코드리뷰 공유
- [x] 사업이 잘되야….
- [x] MariaDB 최근 DB 스키마 변경 공유 (임시테이블)
- [x] 주혁 기록 공유
- [x] 코드리뷰 설명
- [x] 이펙티브 코틀린의 리뷰, 여러번의 상담
- [ ] 테스트 오거나이저
- [ ] 주혁 서비스 대장애 원인


















































