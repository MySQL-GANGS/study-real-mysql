## ch8 : 인덱스

### p. 가장 첫부분

- 인덱스는 sorted-list다! == 매우 중요함
- 검색에 빠른 이유이기 때문에

### p.244 두번째 문단

- InnoDB 는 인덱스 추가작업을 지연을 하는데 PrimaryKey 나 유니크 인덱스의 경우 중복체크가 필요하기때문에 즉시 B-Tree에 추가하거나 삭제해야한다고함
- 왜 PrimaryKey 나 유니크 인덱스는 즉시 B-Tree 반영할까?

### p.255, 4번째줄

- INSERT, UPDATE, DELETE 작업시ㅣ 인덱스 관리에 따르는 추가비용을 감당하면서도… 빠른검색을 위해서다.
- ***부등호 비교조건에서도 인덱스를 사용할수 있지만== 범위 검색
	- 1건 이상의 데이터 검색시 사용되고.
- 정렬 ***인덱스를 이용한 검색은 최소 left-most part 일치하거나 정확히 일치해야하고 100% == 정렬되어있어서

### p.225 인덱스 성능 영향 설명

	InnoDB 스토리지 엔진은 디스크에 데이터를 저장하는 가장 기본 단위를 페이지(Page) 또는 블록이라고 한다.
	디스크의 모든 읽기 및 쓰기 작업의 최소 작업 단위가 된다.
	페이지는 스토리지 엔진의 버퍼풀에서 데이터를 버퍼링(버퍼풀)하는 기본단위기도하다.
	인덱스도 결국 페이지 단위로 관리되고 인덱스의 루트, 브랜치, 리프노드도 페이지 단위로 구분이 된다.
	페이지 단위로 관리 == 키 크기가 성능에 영향을 미치는데

* 키값의 크기
	* 페이지 하나의 갯수제한이 걸림
		* 4KB~64KB까지 저장이 가능한데, 기본설정인 16KB 기준 인덱스 페이지 하나에 585개의 키가 저장이 가능한다고함
		* 예를들어서 데이터가 인덱스 페이지 하나에 들어있다면 디스크를 한번 읽고 해결될 수도있는 문제를 두번 읽게된다는 것
		* 최대한 한번읽는 경우의 수가 클러스터링 인덱스가 가장 흔하더라고 (InnoDB)
	* DB 전체로 보고 메모리에 캐싱할 수있는 갯수는 제한적인것을 염두에 두어야한다.
		* 인덱스도 페이지
		* 페이지를 버퍼풀(메모리) ***인덱스 검색에 최적화
		* 메모리 가득차면 disk I/O 메모리작업 몇십만배 느리기 때문에.
		* ***메모리관리 필수
* 인덱스 깊이
	* 중요하지만 직접 제어할 방법은 없다.
	* B-Tree 가 바이너라기 아니라 밸런스, N개의 child node
	* Depth 10개미만 5개 정도
* 선택도, 기수성 == 인덱스의 밀도 (uniqueness)
	* 인덱스에서 선택도(selectivity)와 기수성(cardinality)는 거으ㅟ 같은 의미로 사용된다.
	* 모든 인덱스 키중에 유니크한 값의 수를 의미
	* 선택도가 높을 수록, 유니크 값의 갯수가 많을수록 빠르게 처리됨.
	* 항상 밀도 높은게 좋은게 아니더라…. Group-by 쿼리, 인덱스에 그룹바이 키가

p.230 가장윗문단

- 인덱스의 손익분기점은 별도 설정정보로 있다*** 궁금하면 참고
- 인덱스의 옵티마이저는 인덱스를 통해 레코드 1건 읽는 것이 직접 테이블에서 1건을 읽는것보다 4~5배 정도 비용이 더 많이 드는 자업이라고해서 읽을 데이터가 전체의 20% 넘어가면 풀스캔한다고함.
	- SQL
	- 옵티마이저
	- 쿼리 비용
	- (주기적으로 업데이트) 테이블의 그래프/통계 보고
	- 20% 이상이면 풀스캔 (테이블페이지)

p.232 밑에서 3번째 줄

* 그림 8.9에서 3건의 레코드가 검색 조건에 일치했다고 하면 3건의 랜덤io가 발생한다.
	* 때문에 20%넘으면 테이블데이터 직접 읽기로 전환함.

인덱스 레인지 스캔

- WHERE 절 활용해서 1건 이상의 데이터 가져오는데 인덱스 활용 ( left most 최대 100%방법으로)
- 실행계획에서도 퉁쳐서 type range

p.233 위에서 2번째 문단에

- 커버링 인덱스는 레코드 조회안하고 인덱스 값으로만 리턴?

P.234

- 인덱스 풀스캔도 테이블 풀스캔 보다는 효율적이다==메모리
- 인덱스에 포함된 칼럼만으로 쿼리를 처리할 수 잇는 경우 베스트
	- 커버링 인덱스

루즈 인덱스 스캔

- 일반적으로 GROUP BY 또는 집합 함수 가운데 MAX() 또는 MIN() 함수에 대해 최적화를 하는 경우에 사용된다 X

p.236
인덱스 스킵 스캔

- **데이터베이스 서버에서 인덱스의 핵심은 값이 정렬돼 있다는 것이다.
- 8.0 버전부터는 ex. 복합키 (Gender, birthdate)에서 gender 뛰어넘고 birthdate 로만도 접근이 가능하다고 함
	- 내부적으로는 gender의 unique 값들 전부 찾아서 검색조건에 넣기때문에 cardility 낮을수록 성능이 좋다.
- Optimizer_switch 옵션을 skip_scan=off 가능하다고함.
- 실행계획에서
	- type 칼럼이
		- index 라면 인덱스 풀스캔이라고함
		- ***우리가 생각하는 인덱스를 사용/활용한다 == type =range 라면 필요한 부분만 읽었다고하는거
	- extra에서
		- Using index for skip scan 은 인덱스 스키비스캔을 활용해 데이터를 조회했다는것
- 인덱스 스킵 스캔의 단점은
	- WHERE 조건절에 조건이 없는 인덱스의 선행 칼럼의 유니크한 값의 갯수가 적어야한다.
		- 요약하면, 선행 인덱스가 많으면 복잡해짐
		- 책에서는, 쿼리 실행 계획의 비용과 관련된 부분인데 유니크한 값의 갯수가 많으면 MySQL 옵티마이저는 인덱스에서 스캔해야 할 시작 지점을 검색하는 작업이 많이 필요해진다고 한다.
	- 쿼리가 인덱스에 존재하는 칼럼만으로 처리 가능해야함(커버링 인덱스)
		- 이건 아직 MySQL 옵티마이저에서 개선이 필요하다고함.

P.240

- 다중컬럼인덱스/복합키는 정렬 기준에 순서도 포함이 되고 검색조건에 큰 영향을 미치기(사용방법)때문에 잘 선택하기

p. 246

- 인덱스 역순 스캔이 인덱스 정순 스캔에 비해 느릴 수 밖에 없는 이유
	- CREATE INDEX …. ASC / DESC (성능 거의 유사)
	- DESC 설정시 DESC 조회 ASC 설정 ASCㄹ
	- 페이지 잠금 (넥스트+ 키갭락) 인덱스 정순 스캔에 적합한구조
	- 페이지 내에서 인덱스 레코드가 단방향으로만 연결된 구조 unidirectional-linkedlist 이기 때문에

P.268 주의

* 인덱스는 컬럼필요 없다
* 가상컬럼과 함수형 인덱스가 성능이 비슷하다고 한다.
* 함수형 인덱스는 함수 표현이 일치해야되는 문제점이 있는데… 관리자 입장에서 생각해보면
	* 개발자의 실수로 인덱스 활용을 못한 쿼리들이 동작하는 것이
	* 개발시에 가상컬럼을 적용안해서 SQL 문이 처음부터 동작하지 않는게
	* 더 관리비용이 적게들 것으로 보인다.
	* 그래서 나는 가급적이면 가상컬럼 사용할 것을 추천하는데
	* CompileError > RuntimeException 낫다.

p.275

* 클러스터링 인덱스
	* InnoDB 기준으로 지원하고 있으며
	* 인덱스의 리프노드에 PK 가 있어서
	* 장점은 빠른 검색, 단점은 느린 쓰기로 읽기 쓰기 비율이 2:8, 1:9 인 OLTP 에 적합하다.
		P.277 마지막 문단 중간쯤 / 유니크인덱스
* 유니크하지 않은 세컨더리 인덱스는 읽어야할 레코드가 많아서 느린 것이지 인덱스 특성 (세컨더리이며 유니크해서) fact 자체 때문은 아니다.

* ***p.278 유니크 인덱스는 중복 값여부를 체크하는 과정이 한 단계 더 필요해서 유니크하지 않은 인덱스 쓰기보다 느리다.
	* 유니크 하다는 특성을 지켜줘야되서
	* InnoDB의 쓰기지연(버퍼) 버퍼가 안되어 변경 작업이 더 느리게 동작한다.
	* 꼭 필요하다면 생성하되 기왕이면 하지말자.

————————————————

스터디
용훈님

- IO에 대해서 정말 잘 알아봄
- 프라이머리키 제목 + 날짜 / AUTO INCREMENT 에 대해서

- [ ] 깃허브에 메모 올리기

ㄹㄹ
