## 내용정리

### 잠금과 트랜잭션

- 잠금은 동시성, 트랜잭션은 데이터 정합성을 보장해주기 위한 것이다.
- 트랜잭션은 작업의 갯수와 관계 없이 `commit`으로 100% 반영되거나 또는 `rollback` 0% 반영되거나 해야한다.
- `MyISAM` 이나 `MEMORY` 은 트랜잭션을 보장해주지 않는다. p.157

#### 트랜잭션 사용시 주의사항 p.158 5.1.2

- 데이터 베이스의 커넥션의 갯수가 제한적인 점을 고려해서 트랜잭션의 실질적인 범위를 최소화한다.
- 예를들어
	- 과부하X : `서버 1대\ (DBCP 스래드 총 40개) \<--> DB 1대== 40대`
	- 과부하O : `서버 2대\ (DBCP 스래드 총 80개) \<--> DB 1대== 40대`
- 외부 작업으로부터 DB사용을 최소화한다.
	- 메일전송, FTP와 같은 외부와 통신하는 작업, 또는 다른 서버나 데이터베이스에 I/O 작업이 이루어지는 부분들은 가능하면 최대한 트랜잭션 내에서 제거한다.
- 작업을 더 작은 단위로 쪼갤 수 있다면 \(CQRS, 도메인 단위 등...)

### 5.2. MySQL 엔진의 잠금

#### MySQL 엔진의 락 p.160

- 글로벌 락
	- 락의 범위 가장 큼
	- 한 세션에서 획득하면 select 문 제외 대부분의 ddl, dml 작업이 대기 상태로 들어간다.
	- InnoDB 스토리지 엔진은 트랜잭션이 지원되서 글로벌 락까지는 필요가 없음.
	- 백업락 : MySQL 8.0 부터 InnoDB 가 기본 스토리지 엔진으로 채택되면서 조금 더 가벼운 글로벌 락의 필요성이 발생
- 네임드 락
	- 문자열에 대해 잠금을 획득하고 반납하는 것
	- 여러 서버가 접속할때 동기화 해야하는 요건들이 발생할 때 사용한다.
- 메타 데이터 락
	- 테이블의 이름이나 구조를 변경하는 경우 자동으로 획득되는 락

### 5.3 InnoDB 의 잠금 p.166

- InnoDB는 MySQL 에서 제공하는 잠금과는 별개로 스토리지 엔진 내부에서 레코드 기반의 잠금 방식을 탑재했는데 잠금정보 진단하기가 까다로웠다.
- 최근에는 잠금 상태관련 정보도 조회가능하다.
	- information_schema 데이터베이스에 존재하는 테이블들을 조인해서 조회 \(innodb_trx, innodb_locks, innodb_lock_waits 라는 테이블들)
	- 트랜잭션의 잠금 대기상태, 잠금 소유 트랜잭션 등을 찾고 장기간 잠금을 유지하는 클라이언트도 종료가능

#### 5.3.1. InnoDB 의 레코드 기반 잠금

##### 5.3.1.1 InnoDB의 레코드 락

- 잠금 정보가 상당히 작은 공간으로 관리되기 때문에 레코드락이 페이지락으로, 또는 테이블 락으로 레벨업 되는 경우는 없다.
- ***중요한 점은 InnoDB 스토리지 엔진은 레코드 자체가 아니라 인덱스의 레코드를 잠근다.
	- ***인덱스가 없어도 내부적으로 생성된 클러스터 인덱스를 이용한다.
	- 프라이머리 키나 유니크 인덱스에 의한 변경작업에서는 갭락 잠금 없이 레코드 자체에서만 락을 건다.
- 참고로 InnoDB에는 레코드와 레코드 사이의 간격을 잠그는 갭 락이 존재한다.

##### 5.3.1.2 갭락이란?

- 갭락은 바로 인접한 레코드와의 사이 간격에 레코드를 잠금하는데 갭에 새로운 레코드가 생성되는 것을 제어함.

##### 5.3.1.3 넥스트 키 락

- 넥스트 키락 = 레코드락 + 갭 락
- 넥스트 키락 을 위해서는 REPEATBLE 격리 수준을 사용해야 한다.
- 바이너리 로그에 기록되는 쿼리가 레플리카 서버에서 실해될 때 소스 서버에서 만들어낸 결과와 동일한 결과를 만들어내도록 보장하는 것이 주목적이다.
- 넥스트 키락이나 갭락으로 인해 데드락이 발생하는 경우도 많음
- binlog 를 ROW 형태로 바꿔서 넥스트 키 락이나 갭 락을 줄이는 것이 좋다.

##### 5.3.1.4 자동 증가 락

- `INSERT` 와 `REPLACE` 와 같이 새로운 레코드를 저장하는 쿼리에서 필요하다. UPDATE나 DELETE에서는 걸리지 않는다.
- 트랜잭션과 관계없이 `INSERT` 나 `REPLACE` 문장에서 `AUTO INCREMENT` 값 가져오는 순간만 락이 걸렸다가 해제돤다.
- 테이블에 단 하나만 존재한다.
- 명시적으로 획득하고 해제하는 방법이 없지만 아주 짧은 시간이라 대부분의 경우는 문제가 되지않는다.

##### 인덱스와 잠금 p.170

- InnoDB의 잠금은 레코드를 잠그는 것이 아니라 인덱스를 잠그는 방식으로 처리된다.
- 즉, 변경해야 할 레코드를 찾기 위해 검색한 인덱스의 레코드를 모두 락을 걸어야 한다.

### 5.4 트랜잭션

#### 트랜잭션의 격리 레벨에 따른 세 가지 부정합

- DIRTY READ : READ_UNCOMMITED 까지 발생
- NON-REPEATABLE READ : READ_COMMITED 까지도 발생
- PHANTOM READ : \(InnoDB 제외) REPEATABLE READ 까지도 발생한

#### 핵심

- `NON-REAPEATABLE READ`는 하나의 트랜잭션 내에서 똑같은 SELECT 쿼리를 실행했을 때는 항상 같은 결과를 가져와야 한다는 `REPEATABLE` 정합성에 어긋나는 것
- **헷갈리지 말아야할 것은** 트랜잭션 내에서 실행되는 `SELECT` 문과 트랜잭션 없이 실행되는 `SELECT`문의 차이를 알아야한다.
	- READ-COMMITED 까지는 별차이가 없지만 `REPEATABLE-READ` 격리수준부터는 `START TRANSACTION....` 이후 실행되는 쿼리는 항상 동일한 결과를 응답해준다.
- `REPEATABLE READ`와 `READ COMMMITED` 모두 **MVCC**가 커밋되기 전의 언두로그 영역의 데이터를 읽어온다.
	- 하지만 이 둘의 차이는 `언두 영역에 백업된 레코드의 여러 버전 가운데 몇 번째 이전 버전까지 찾아들어가는가....` 에 있다.
	- InnoDB의 트랜잭션은 고유하고 순차적으로 증가하는 트랜잭션 번호를 가지고 있다.
	- 실행중인 가장 오래된 트랜잭션 아이디보다 이전 트랜잭션 번호를 가진 언두 영역의 데이터는 삭제할 수 없다.
- REPEATABLE-READ 격리 수준에서 발생하는 `PHANTOM READ`가 발생하지 않는다고 하는데..
	이유를 [MySQL 문서](https://dev.mysql.com/doc/refman/8.0/en/innodb-next-key-locking.html)에서 찾을 수 있었다.
	- InnoDB 는 인덱스 로우 락\(== 레코드 락) 락과 갭락이 조합된 넥스트 키 락킹을 사용해서 팬텀을 방지한다.
	- > By default, InnoDB operates in REPEATABLE READ transaction isolation level. In this case, InnoDB uses next-key
		locks
		for searches and index scans, which prevents phantom
		rows [\(see Section 15.7.4, “Phantom Rows”)](https://dev.mysql.com/doc/refman/8.0/en/innodb-next-key-locking.html)
- SERIALIZABLE 로 설정되면 읽기작업도 공유 잠금을 획득해야만 하며, 동시에 다른 트랜잭션은 그러한 레코드를 변경하지 못하게 된다.
	- 상식적으로는 PHANTOM READ 가 SERIALIZABLE 격리 수준부터 발생하지 않는다.
	- 하지만 InnoDB는 갭락과 넥스트 키 락 덕분에 REPEATABLE READ 수준에서 이미 PHANTOM READ 가 방지된다.

### 질문들

- p. 166 / 트랜잭션을 autocommit 으로 하고 BEGIN 이나 start transaction 으로 실행하면 안되는 이유가 도대체 뭘까
