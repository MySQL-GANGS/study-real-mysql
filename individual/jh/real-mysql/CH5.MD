## 내용정리 

### 잠금과 트랜잭션

- 잠금은 동시성, 트랜잭션은 데이터 정합성을 보장해주기 위한 것이다.
- 트랜잭션은 작업의 갯수와 관계 없이 `commit`으로 100% 반영되거나 또는 `rollback` 0% 반영되거나 해야한다.
- p.157 보면 `MyISAM` 이나 `MEMORY` 은 트랜잭션이 없다.
- p.158 5.1.2 트랜잭션 사용시 주의사항
	- 데이터 베이스의 커넥션의 갯수가 제한적인 점을 고려해서 트랜잭션의 실질적인 범위를 최소화 한다.
	- 메일전송, FTP와 같은 외부와 통신하는 작업은 최대한 트랜잭션 내에서 제거한다.
	- 작업을 더 작은 단위로 쪼갤 수 있다면 \(CQRS, 도메인 단위 등...) 

### 5.2. MySQL 엔진의 잠금

- MySQL 엔진의 락 p.160
  - 글로벌 락
    - 락의 범위 가장 큼  
    - 한 세션에서 획득하면 select 문 제외 대부분의 ddl, dml 작업이 대기 상태로 들어간다.
    - InnoDB 스토리지 엔진은 트랜잭션이 지원되서 글로벌 락까지는 필요가 없음.
    - 백업락 : MySQL 8.0 부터 InnoDB 가 기본 스토리지 엔진으로 채택되면서 조금 더 가벼운 글로벌 락의 필요성이 발생
  - 네임드 락
    - 문자열에 대해 잠금을 획득하고 반납하는 것
    - 여러 서버가 접속할때 동기화 해야하는 요건들이 발생할 때 사용한다.
  - 메타 데이터 락
    - 테이블의 이름이나 구조를 변경하는 경우 자동으로 획득되는 락
  
### 5.3 InnoDB 의 잠금 p166
  - InnoDB는 MySQL 에서 제공하는 잠금과는 별개로 스토리지 엔진 내부에서 레코드 기반의 잠금 방식을 탑재했는데 잠금정보 진단하기가 까다로웠다.
  - 최근에는 information_schema 데이터베이스에ㅑ존재하는 innodb_trx, innodb_locks, innodb_lock_waits 라는 테이블들을 조인해서 조회하면 트랜잭션의 잠금 대기상태, 잠금 소유 트랜잭 등을 찾고 장기간 잠금을 유지하는 클라이언트도 종료가능
  - 5.3.1. INNODB의 레코드 기반 잠금
    - 5.3.1.1 InnoDB의 레코드 락
      - 잠금 정보가 상당히 작은 공간으로 관리되기 때문에 레코드락이 페이지락으로, 또는 테이블 락으로 레벨업 되는 경우는 없다.
      - ***중요한 점은 InnoDB 스ㅗ리지 엔진은 레코드 자체가 아니라 인덱스의 레코드를 잠근다.
        - 인덱스가 없어도 내부적으로 생성된 클러스터 인덱스를 이용한다.
        - 프라이머리 키나 유니크 인덱스에 의한 변경작업에서는 갭락 잠금 없이 레코드 자체에서만 락을 건다.
      - 참고로 InnoDB에는 레코드와 레코드 사이의 간격을 잠그는 갭 락이 존재한다.
    - 5.3.1.2 갭락
      - 갭락은 레코드자체가 이날 레코드와 바로 인접한 레코드 사이의 간격을 잠금하는데 갭에 새로운 레코드가 생성되는 것을 제어함.
    - 5.3.1.3 넥스트 키 락
      - 레코드락 + 갭 락
      - REPEATBLE 격리 수준을 사용해야 한다.
    - 5.3.1.4 자동 증가 락
      - INSERT와 replace 와 같이 새로운 레코드를 저장하는 쿼리에서ㄴ 필요하다. UPDATE나 DELETE에서는 걸리지 않는다.
      - 트랜잭션과 관계없이 insert나 replce 문장에서 auto increment 값 가져오는 순간만 락이 걸렸다가 해제돤다.
      - 테이블에 단 하나만 존재한다.
      - 명시적으로 획득하고 해제하는 방법이 없지만 아주 짧은 시간이라 대부분의 경우는 문제가 되지않는다.
  - 인덱스와 잠금 p.170j
    - InnoDB의 잠금은 레코드를 잠그는 것이 아니라 인덱스를 잠그는 방식으로 처리된다.
    - 즉, 변경해야 할 레코드를 찾기 위해 검색한 인덱스으 레코드를 모두 락을 걸어야 한다.

### 5.4 트랜잭션

- 트랜잭션의 격리 레벨에 따른 세 가지 부정합
  - DIRTY READ : ~ READ_UNCOMMITED
  - NON-REPEATABLE READ : ~ READ_COMMITED
  - PHANTOM READ : InnoDB는 없는 ~ REPEATABLE READ
  - 

## 질문들
- p. 166 / 트랜잭션을 autocommit 으로 하고 BEGIN 이나 start transaction 으로  실행하면 안되는이유가....
