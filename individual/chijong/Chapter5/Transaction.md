# 트랜잭션과 잠금
MySQL 동시성 <- 잠금(Lock)  트랜잭션, 트랜잭션의 격리수준(Isolation Level)


트랜잭션 : 논리적인 작업 셋이 불완전할 경우 원 상태로 복구. 
Partial update : 작업의 일부만 적용되는 현상. 

Lock : 동시성을 제어하기 위한 기능  - 여러 커넥션에서 동시에 동일한 자원(레코드나 테이블)을 요청할 경우 순서대로 한 시점에는 하나의 커넥션만 변경할 수 있게 해주는 역할.

트랜잭션 : 데이터의 정합성을 보장하기 위한 기능. 

격리수준 : 하나의 트랜잭션 내에서 또는 여러 트랜잭션 간의 작업 매뇽을 어떻게 공유하고 차단할 것인지를 결정하는 레벨. 


## 트랜잭션
---
MyISAM, MEMORY 스토리지 엔진은 트랜잭션을 지원하지 않음. 

하나의 논리적인 작업 셋이 100% 적용되거나 100%적용되지 않거나를 보장.

Partial Update가 일어난 결우 실패한 쿼리로 인해 실패하기 이전에 적용된 쿼리의 내용을 다시 보정하는 작업이 필요할지도 모른다. 

* 트랜잭션의 범위는 최소화. 
* 일반적으로 데이터베이스 커넥션 개수는 제한적.  단위 프로그램의 커넥션 소유 기간 최소화. 
* 메일 전송, FTP파일 전송 작업, 네트워크를 통해 원격 서버와 통신 작업 -> DBMS의 트랜잭션 내에서 제거하는 것이 좋음. 


## Lock
---
MySQL에서 Lock : 스토리지 엔진 레벨과 MySQL 엔진 레벨로 나뉨.

* MySQL엔진 레벨 잠금 : 모든 스토리지 엔진에 영향. 테이블 락, 메타데이터 락, 네이므드 락 제공.
* 스토리지엔진 레벨 잠금 : 스토리지 엔진 간 상호 영향 없음.

### 글로벌 락
가장 범위가 큰 잠금. 범위 : MySQL 서버 전체. 테이블이나 데이터베이스가 다르더라도 동일 영향.

명령어 : FLUSH TABLES WITH READ LOCK.
  - 실행과 동시에 모든 테이블을 닫고 잠금.
  - 이전 쿼리가 종료될 때까지 기다려야함. 
  - mysqldump를 이용해 백업하면 이 명령이 내부적으로 실행될 수 있음. 확인 필요. 

MyISAM or MEMORY 스토리지 엔진 -> InnoDB 스토리지 엔진 사용 일반화
 -> InnoDB는 트랜잭션 지원 -> 모든 데이터 변경 작업을 멈출 필요는 없음
 조금 더 가벼운 글로벌 락의 필요성 -> Xtrabackup, Enterprise Backup과 같은 백업 툴들의 안정적인 실행을 위해 백업 락이 도입. 

 ### 테이블 락
 개별  테이블 단위로 설정되는 잠금. 
 * 명시적 : "LOCK TABLES table_name [READ | WRITE]" 명령으로 특정 테이블 락 획득. 반납 : "UNLOCK TABLES"
 * 묵시적 : MyISAM이나 MEMORY테이블에 데이터를 변경하는 쿼리를 실행하면 발생한다. InnoDB테이블에는 DML말고 DDL인 경우에만 영향을 미친다. 

### 네임드 락
* GET_LOCK()함수를 이용해 임의의 문자열에 대해 잠금을 설정. 

### 메타데이터 락
* 데이터베이스 객체(대표적으로 테이블이나 뷰 등)의 이름이나 구조를 변경하는 경우에 획득하는 잠금
* RENAME명령어를 쓸 때 실행된다.
* RENAME TABLE tab_a T0 tab_b같이 테이블의 이름을 변경하는 경우 자동으로 획득하는 잠금
* RENAME TABLE rank T0 rank_backup, rank_new T0 rank 같은 쿼리는 아주 잠깐이지만 rank테이블이 존재하지 않는 경우를 만들어 낼 수 있어서 Table not found 'rank라는 오류를 발생.

MySQL서버의 Online DDL?
Online DDL이 실행되는 동안 누적된 Online DDL 버퍼의 크기, 언두 로그의증가.
DDL은 단일 스레드. -> 많은 시간 소모.

--> 최근의 데이터는 pk를 나눠서 미리 복사.. 나머지는 테이블쓰기 락을 걸어서 복사..

그러면 락이 걸린 동안에는 최근의 데이터를 쓸 것이고....   서비스에 지장이 없는 동안 복사를 하게 된다.  

## Inno DB 스토리지 엔진 잠금
---
스토리지 엔진 내부에서 레코드 기반의 잠금방식 탑재.
-> MYISAM보다는 훨씬 뛰어난 동시성 처리를 제공할 수 있다. 

이원화된 잠금??? 

InnoDB의 트랜잭션과 잠금, 그리고 잠김 대기 중인 트랜잭션의 목록을 조회할 수 있는 방법 
: MySQL서버의 information_schema 데이터베이스에 존재하는 INNODB_TRX, INNODB_LOCKS, INNODB_LOCK_WAITS라는 테이블을 조인해서 조회. 

Performance Schema를 이용해 InnoDB 스토리지 엔진의 내부잠금(세마포어)에 대한 모니터링 방법도 추가.

* 잠금 정보가 상당히 작은 공간. 레코드락-> 페이지락 -> 테이블 락 레벨업 없음.
* GAP락 : 레코드와 레코드 사이를 잠금

### 레코드 락
* 인덱스의 레코드를 잠금.
* 인덱스가 없는 테이블 -> 내부적으로 자동 생성된 클러스터 인덱스를 이용해 잠금.

### 갭 락
* 레코드와 바로 인접한 레코드 사이의 간격만을 잠감.
* 레코드와 레코드 사이의 간격에 새로운 레코드가 생성되는 것을 제어

### 넥스트 키 락
* 레코드 락 + 갭 락
* STATEMENT 포맷의 바이너리 로그를 사용하는 MySQL 서버에서는 REPEATABLE READ 격리 수준을 사용해야 한다. 

### 자동 증가 락
* AUTO_INCREMENT락이라고 하는 테이블 수준의 잠금
* 새로운 레코드를 저장하는 쿼리에서만 필요함
* INSERT, REPLACE문장에서 AUTO_INCREMENT값을 가져오는 순간만 락이 걸렸다가 해제

#### MySQL 5.0이상
innodb_autoinc_lock_mode = 0   : 모든 INSERT 문장은 자동 증가 락을 사용

innodb_autoinc_loc_mode = 1 : INSERT하는 레코드의 개수를 정확히 예측할 수 있을 때 사용. 

innodb_autoinc_lock_mode = 2 경량화된 래치(뮤텍스)를 사용. == interleaved mode   : 하나의 INSERT문장으로 INSERT되는 레코드라고 하더라도 연속된 자동증가 값을 보장하지는 않음. 

## 인덱스와 잠금
---
레코드를 찾기 위해 검색한 인덱스의 레코드를 모두 락을 걸어야 한다.
인덱스를 걸지 않으면 update를 위해 모든 레코드의 인덱스에 락을 걸어야 할 수도 있다. 

MySQL 5.1부터 레코드 잠금과 잠금 대기에 대한 조회가 가능하므로 쿼리 하나만 실행해 보면 잠금과 잠금대기를 바로 확인할 수 있다. 

* commit을 하지 않으면 업데이트한 레코드의 잠금을 그대로 가진다.
* SHOW PROCESSLIST;
* performance_schema의 data_locks테이블과 data_lock_waits테이블을 조인해서 잠김 대기 순서를 확인.
* KILL명령어를 이용해 스레드를 강제 종료. 

## MySQL의 격리 수준
---
* READ UNCOMMITTED
* READ COMMITTED
* REPEATABLE READ
* SERIALIZABLE

뒤로 갈 수록 각 트랜잭션 간의 데이터 격리정도가 높아지며, 동시 처리 성능도 떨어지는 것이 일반적.

### READ UNCOMMITTED
* SERIALIZABLE격리 수준이 아니라면 크게 성능의 개선이나 저하는 발생하지 않음. 

* Dirty read : 어떤 트랜잭션에서 처리한 작업이 완료되지 않았는데도 다른 트랜잭션에서 볼 수 있는 현상.  READ UNCOMMITTED는 Dirty read를 허용. 

### READ COMMITTED
* 언두로그를 이용해 commit전의 데이터를 읽는다. 
* REPEATABLE READ 정합성 : 하나의 트랜잭션 내에서 똑같은 SELECT쿼리르 ㄹ실행했을 때는 항상 같은 결과를 가져와야 한다는 정합성.
* PHANTOM READ or PHANTOM ROW : 다른 트랜잭션에서 수행한 변경 작업에 의해 레코드가 보였다 안 보였다 하는 현상.

### SERIALIZABLE
* 가장 단순한 격리 수준이면서 동시에 가장 엄격한 격리 수준.
* 동시 처리 성능도 다른 트랜잭션 격리 수준보다 떨어진다. 
* 읽기 작업도 공유 잠금을 획득해야만 한다. 
* 그러나 InnoDB 스토리지 엔진에서는 갭 락과 넥스트 키 락 덕분에 REPEATABLE READ격리 수준에서도 이미 PHANTOM READ가 발생하지 않기 때문에 굳이 SERIALIZABLE을 사용할 필요성은 없다.